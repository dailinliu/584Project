<DOCTYPE html>
<html>
  <head>
    <title>Memcached Source Code</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Bootstrap -->
    <!-- Latest compiled and minified CSS -->
    <link rel="stylesheet" href="http://netdna.bootstrapcdn.com/bootstrap/3.0.2/css/bootstrap.min.css">
    <!-- Optional theme -->
    <link rel="stylesheet" href="http://netdna.bootstrapcdn.com/bootstrap/3.0.2/css/bootstrap-theme.min.css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
      <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->
	<!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
	<script type="text/javascript" src="https://code.jquery.com/jquery.js"></script>
	<script type="text/javascript" src="http://code.jquery.com/jquery-1.7.2.min.js"></script>
	<!-- Include all compiled plugins (below), or include individual files as needed -->
	<!-- Latest compiled and minified JavaScript -->
	<script type="text/javascript" src="http://netdna.bootstrapcdn.com/bootstrap/3.0.2/js/bootstrap.min.js"></script>
  </head>
  <body>
	  <nav class="navbar navbar-default" role="navigation">
	    <!-- Brand and toggle get grouped for better mobile display -->
	    <div class="navbar-header">
	      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
	        <span class="sr-only">Toggle navigation</span>
	        <span class="icon-bar"></span>
	        <span class="icon-bar"></span>
	        <span class="icon-bar"></span>
	      </button>
	      <a class="navbar-brand" href="#">Memcached Code</a>
	    </div>

	    <!-- Collect the nav links, forms, and other content for toggling -->
	    <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
	      <ul class="nav navbar-nav">
	        <li class="active"><a href="memcachedc.html">memcached.c</a></li>
	        <li><a href="memcachedh.html">memcached.h</a></li>
	      </ul>
	    </div><!-- /.navbar-collapse -->
	  </nav>
	 
  	  <div class="panel-group" id="accordion" style="padding:19px 19px;">
    	    <div class="panel panel-default">
    	      <div class="panel-heading">
    	        <h4 class="panel-title">
    	          <a data-toggle="collapse" data-parent="#accordion" href="#introduction">
  				  Introduction
    	          </a>
    	        </h4>
    	      </div>
    	      <div id="introduction" class="panel-collapse collapse in">
    	        <div class="panel-body">
    	          <pre>
  				  memcached.c
    	          </pre>
    	        </div>
    	      </div>
    	    </div>
  	    <div class="panel panel-default">
  	      <div class="panel-heading">
  	        <h4 class="panel-title">
  	          <a data-toggle="collapse" data-parent="#accordion" href="#drive_machine">
  	            static void drive_machine(conn *c)
  	          </a>
  	        </h4>
  	      </div>
  	      <div id="drive_machine" class="panel-collapse collapse">
  	        <div class="panel-body">
  				<pre>
  					static void drive_machine(conn *c) {
  					    bool stop = false;
  					    int sfd, flags = 1;
  					    socklen_t addrlen;
  					    struct sockaddr_storage addr;
  					    int nreqs = settings.reqs_per_event;
  					    int res;
  					    const char *str;

  					    assert(c != NULL);

  					    while (!stop) {

  					        switch(c->state) {
  					        case conn_listening:
  					            addrlen = sizeof(addr);
  					            if ((sfd = accept(c->sfd, (struct sockaddr *)&addr, &addrlen)) == -1) {
  					                if (errno == EAGAIN || errno == EWOULDBLOCK) {
  					                    /* these are transient, so don't log anything */
  					                    stop = true;
  					                } else if (errno == EMFILE) {
  					                    if (settings.verbose > 0)
  					                        fprintf(stderr, "Too many open connections\n");
  					                    accept_new_conns(false);
  					                    stop = true;
  					                } else {
  					                    perror("accept()");
  					                    stop = true;
  					                }
  					                break;
  					            }
  					            if ((flags = fcntl(sfd, F_GETFL, 0)) < 0 ||
  					                fcntl(sfd, F_SETFL, flags | O_NONBLOCK) < 0) {
  					                perror("setting O_NONBLOCK");
  					                close(sfd);
  					                break;
  					            }

  					            if (settings.maxconns_fast &&
  					                stats.curr_conns + stats.reserved_fds >= settings.maxconns - 1) {
  					                str = "ERROR Too many open connections\r\n";
  					                res = write(sfd, str, strlen(str));
  					                close(sfd);
  					                STATS_LOCK();
  					                stats.rejected_conns++;
  					                STATS_UNLOCK();
  					            } else {
  					                dispatch_conn_new(sfd, conn_new_cmd, EV_READ | EV_PERSIST,
  					                                     DATA_BUFFER_SIZE, tcp_transport);
  					            }

  					            stop = true;
  					            break;

  					        case conn_waiting:
  					            if (!update_event(c, EV_READ | EV_PERSIST)) {
  					                if (settings.verbose > 0)
  					                    fprintf(stderr, "Couldn't update event\n");
  					                conn_set_state(c, conn_closing);
  					                break;
  					            }

  					            conn_set_state(c, conn_read);
  					            stop = true;
  					            break;

  					        case conn_read:
  					            res = IS_UDP(c->transport) ? try_read_udp(c) : try_read_network(c);

  					            switch (res) {
  					            case READ_NO_DATA_RECEIVED:
  					                conn_set_state(c, conn_waiting);
  					                break;
  					            case READ_DATA_RECEIVED:
  					                conn_set_state(c, conn_parse_cmd);
  					                break;
  					            case READ_ERROR:
  					                conn_set_state(c, conn_closing);
  					                break;
  					            case READ_MEMORY_ERROR: /* Failed to allocate more memory */
  					                /* State already set by try_read_network */
  					                break;
  					            }
  					            break;

  					        case conn_parse_cmd :
  					            if (try_read_command(c) == 0) {
  					                /* wee need more data! */
  					                conn_set_state(c, conn_waiting);
  					            }

  					            break;

  					        case conn_new_cmd:
  					            /* Only process nreqs at a time to avoid starving other
  					               connections */

  					            --nreqs;
  					            if (nreqs >= 0) {
  					                reset_cmd_handler(c);
  					            } else {
  					                pthread_mutex_lock(&c->thread->stats.mutex);
  					                c->thread->stats.conn_yields++;
  					                pthread_mutex_unlock(&c->thread->stats.mutex);
  					                if (c->rbytes > 0) {
  					                    /* We have already read in data into the input buffer,
  					                       so libevent will most likely not signal read events
  					                       on the socket (unless more data is available. As a
  					                       hack we should just put in a request to write data,
  					                       because that should be possible ;-)
  					                    */
  					                    if (!update_event(c, EV_WRITE | EV_PERSIST)) {
  					                        if (settings.verbose > 0)
  					                            fprintf(stderr, "Couldn't update event\n");
  					                        conn_set_state(c, conn_closing);
  					                    }
  					                }
  					                stop = true;
  					            }
  					            break;

  					        case conn_nread:
  					            if (c->rlbytes == 0) {
  					                complete_nread(c);
  					                break;
  					            }
  					            /* first check if we have leftovers in the conn_read buffer */
  					            if (c->rbytes > 0) {
  					                int tocopy = c->rbytes > c->rlbytes ? c->rlbytes : c->rbytes;
  					                if (c->ritem != c->rcurr) {
  					                    memmove(c->ritem, c->rcurr, tocopy);
  					                }
  					                c->ritem += tocopy;
  					                c->rlbytes -= tocopy;
  					                c->rcurr += tocopy;
  					                c->rbytes -= tocopy;
  					                if (c->rlbytes == 0) {
  					                    break;
  					                }
  					            }

  					            /*  now try reading from the socket */
  					            res = read(c->sfd, c->ritem, c->rlbytes);
  					            if (res > 0) {
  					                pthread_mutex_lock(&c->thread->stats.mutex);
  					                c->thread->stats.bytes_read += res;
  					                pthread_mutex_unlock(&c->thread->stats.mutex);
  					                if (c->rcurr == c->ritem) {
  					                    c->rcurr += res;
  					                }
  					                c->ritem += res;
  					                c->rlbytes -= res;
  					                break;
  					            }
  					            if (res == 0) { /* end of stream */
  					                conn_set_state(c, conn_closing);
  					                break;
  					            }
  					            if (res == -1 && (errno == EAGAIN || errno == EWOULDBLOCK)) {
  					                if (!update_event(c, EV_READ | EV_PERSIST)) {
  					                    if (settings.verbose > 0)
  					                        fprintf(stderr, "Couldn't update event\n");
  					                    conn_set_state(c, conn_closing);
  					                    break;
  					                }
  					                stop = true;
  					                break;
  					            }
  					            /* otherwise we have a real error, on which we close the connection */
  					            if (settings.verbose > 0) {
  					                fprintf(stderr, "Failed to read, and not due to blocking:\n"
  					                        "errno: %d %s \n"
  					                        "rcurr=%lx ritem=%lx rbuf=%lx rlbytes=%d rsize=%d\n",
  					                        errno, strerror(errno),
  					                        (long)c->rcurr, (long)c->ritem, (long)c->rbuf,
  					                        (int)c->rlbytes, (int)c->rsize);
  					            }
  					            conn_set_state(c, conn_closing);
  					            break;

  					        case conn_swallow:
  					            /* we are reading sbytes and throwing them away */
  					            if (c->sbytes == 0) {
  					                conn_set_state(c, conn_new_cmd);
  					                break;
  					            }

  					            /* first check if we have leftovers in the conn_read buffer */
  					            if (c->rbytes > 0) {
  					                int tocopy = c->rbytes > c->sbytes ? c->sbytes : c->rbytes;
  					                c->sbytes -= tocopy;
  					                c->rcurr += tocopy;
  					                c->rbytes -= tocopy;
  					                break;
  					            }

  					            /*  now try reading from the socket */
  					            res = read(c->sfd, c->rbuf, c->rsize > c->sbytes ? c->sbytes : c->rsize);
  					            if (res > 0) {
  					                pthread_mutex_lock(&c->thread->stats.mutex);
  					                c->thread->stats.bytes_read += res;
  					                pthread_mutex_unlock(&c->thread->stats.mutex);
  					                c->sbytes -= res;
  					                break;
  					            }
  					            if (res == 0) { /* end of stream */
  					                conn_set_state(c, conn_closing);
  					                break;
  					            }
  					            if (res == -1 && (errno == EAGAIN || errno == EWOULDBLOCK)) {
  					                if (!update_event(c, EV_READ | EV_PERSIST)) {
  					                    if (settings.verbose > 0)
  					                        fprintf(stderr, "Couldn't update event\n");
  					                    conn_set_state(c, conn_closing);
  					                    break;
  					                }
  					                stop = true;
  					                break;
  					            }
  					            /* otherwise we have a real error, on which we close the connection */
  					            if (settings.verbose > 0)
  					                fprintf(stderr, "Failed to read, and not due to blocking\n");
  					            conn_set_state(c, conn_closing);
  					            break;

  					        case conn_write:
  					            /*
  					             * We want to write out a simple response. If we haven't already,
  					             * assemble it into a msgbuf list (this will be a single-entry
  					             * list for TCP or a two-entry list for UDP).
  					             */
  					            if (c->iovused == 0 || (IS_UDP(c->transport) && c->iovused == 1)) {
  					                if (add_iov(c, c->wcurr, c->wbytes) != 0) {
  					                    if (settings.verbose > 0)
  					                        fprintf(stderr, "Couldn't build response\n");
  					                    conn_set_state(c, conn_closing);
  					                    break;
  					                }
  					            }

  					            /* fall through... */

  					        case conn_mwrite:
  					          if (IS_UDP(c->transport) && c->msgcurr == 0 && build_udp_headers(c) != 0) {
  					            if (settings.verbose > 0)
  					              fprintf(stderr, "Failed to build UDP headers\n");
  					            conn_set_state(c, conn_closing);
  					            break;
  					          }
  					            switch (transmit(c)) {
  					            case TRANSMIT_COMPLETE:
  					                if (c->state == conn_mwrite) {
  					                    while (c->ileft > 0) {
  					                        item *it = *(c->icurr);
  					                        assert((it->it_flags & ITEM_SLABBED) == 0);
  					                        item_remove(it);
  					                        c->icurr++;
  					                        c->ileft--;
  					                    }
  					                    while (c->suffixleft > 0) {
  					                        char *suffix = *(c->suffixcurr);
  					                        cache_free(c->thread->suffix_cache, suffix);
  					                        c->suffixcurr++;
  					                        c->suffixleft--;
  					                    }
  					                    /* XXX:  I don't know why this wasn't the general case */
  					                    if(c->protocol == binary_prot) {
  					                        conn_set_state(c, c->write_and_go);
  					                    } else {
  					                        conn_set_state(c, conn_new_cmd);
  					                    }
  					                } else if (c->state == conn_write) {
  					                    if (c->write_and_free) {
  					                        free(c->write_and_free);
  					                        c->write_and_free = 0;
  					                    }
  					                    conn_set_state(c, c->write_and_go);
  					                } else {
  					                    if (settings.verbose > 0)
  					                        fprintf(stderr, "Unexpected state %d\n", c->state);
  					                    conn_set_state(c, conn_closing);
  					                }
  					                break;

  					            case TRANSMIT_INCOMPLETE:
  					            case TRANSMIT_HARD_ERROR:
  					                break;                   /* Continue in state machine. */

  					            case TRANSMIT_SOFT_ERROR:
  					                stop = true;
  					                break;
  					            }
  					            break;

  					        case conn_closing:
  					            if (IS_UDP(c->transport))
  					                conn_cleanup(c);
  					            else
  					                conn_close(c);
  					            stop = true;
  					            break;

  					        case conn_max_state:
  					            assert(false);
  					            break;
  					        }
  					    }

  					    return;
  					}
				
  				</pre>
  	        </div>
  	      </div>
  	    </div>
  	    <div class="panel panel-default">
  	      <div class="panel-heading">
  	        <h4 class="panel-title">
  	          <a data-toggle="collapse" data-parent="#accordion" href="#new_socket">
  	            static int new_socket(struct addrinfo *ai)
  	          </a>
  	        </h4>
  	      </div>
  	      <div id="new_socket" class="panel-collapse collapse">
  	        <div class="panel-body">
  				<pre>
  				static int new_socket(struct addrinfo *ai) {
  				    int sfd;
  				    int flags;

  				    if ((sfd = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol)) == -1) {
  				        return -1;
  				    }

  				    if ((flags = fcntl(sfd, F_GETFL, 0)) < 0 ||
  				        fcntl(sfd, F_SETFL, flags | O_NONBLOCK) < 0) {
  				        perror("setting O_NONBLOCK");
  				        close(sfd);
  				        return -1;
  				    }
  				    return sfd;
  				}
  			</pre>
  	        </div>
  	      </div>
  	    </div>
  	    <div class="panel panel-default">
  	      <div class="panel-heading">
  	        <h4 class="panel-title">
  	          <a data-toggle="collapse" data-parent="#accordion" href="#try_read_command">
  	            static int try_read_command(conn *c)
  	          </a>
  	        </h4>
  	      </div>
  	      <div id="try_read_command" class="panel-collapse collapse">
  	        <div class="panel-body">
  				<pre>
  				static int try_read_command(conn *c) {
  				    assert(c != NULL);
  				    assert(c->rcurr <= (c->rbuf + c->rsize));
  				    assert(c->rbytes > 0);

  				    if (c->protocol == negotiating_prot || c->transport == udp_transport)  {
  				        if ((unsigned char)c->rbuf[0] == (unsigned char)PROTOCOL_BINARY_REQ) {
  				            c->protocol = binary_prot;
  				        } else {
  				            c->protocol = ascii_prot;
  				        }

  				        if (settings.verbose > 1) {
  				            fprintf(stderr, "%d: Client using the %s protocol\n", c->sfd,
  				                    prot_text(c->protocol));
  				        }
  				    }

  				    if (c->protocol == binary_prot) {
  				        /* Do we have the complete packet header? */
  				        if (c->rbytes < sizeof(c->binary_header)) {
  				            /* need more data! */
  				            return 0;
  				        } else {
  				#ifdef NEED_ALIGN
  				            if (((long)(c->rcurr)) % 8 != 0) {
  				                /* must realign input buffer */
  				                memmove(c->rbuf, c->rcurr, c->rbytes);
  				                c->rcurr = c->rbuf;
  				                if (settings.verbose > 1) {
  				                    fprintf(stderr, "%d: Realign input buffer\n", c->sfd);
  				                }
  				            }
  				#endif
  				            protocol_binary_request_header* req;
  				            req = (protocol_binary_request_header*)c->rcurr;

  				            if (settings.verbose > 1) {
  				                /* Dump the packet before we convert it to host order */
  				                int ii;
  				                fprintf(stderr, "<%d Read binary protocol data:", c->sfd);
  				                for (ii = 0; ii < sizeof(req->bytes); ++ii) {
  				                    if (ii % 4 == 0) {
  				                        fprintf(stderr, "\n<%d   ", c->sfd);
  				                    }
  				                    fprintf(stderr, " 0x%02x", req->bytes[ii]);
  				                }
  				                fprintf(stderr, "\n");
  				            }

  				            c->binary_header = *req;
  				            c->binary_header.request.keylen = ntohs(req->request.keylen);
  				            c->binary_header.request.bodylen = ntohl(req->request.bodylen);
  				            c->binary_header.request.cas = ntohll(req->request.cas);

  				            if (c->binary_header.request.magic != PROTOCOL_BINARY_REQ) {
  				                if (settings.verbose) {
  				                    fprintf(stderr, "Invalid magic:  %x\n",
  				                            c->binary_header.request.magic);
  				                }
  				                conn_set_state(c, conn_closing);
  				                return -1;
  				            }

  				            c->msgcurr = 0;
  				            c->msgused = 0;
  				            c->iovused = 0;
  				            if (add_msghdr(c) != 0) {
  				                out_string(c, "SERVER_ERROR out of memory");
  				                return 0;
  				            }

  				            c->cmd = c->binary_header.request.opcode;
  				            c->keylen = c->binary_header.request.keylen;
  				            c->opaque = c->binary_header.request.opaque;
  				            /* clear the returned cas value */
  				            c->cas = 0;

  				            dispatch_bin_command(c);

  				            c->rbytes -= sizeof(c->binary_header);
  				            c->rcurr += sizeof(c->binary_header);
  				        }
  				    } else {
  				        char *el, *cont;

  				        if (c->rbytes == 0)
  				            return 0;

  				        el = memchr(c->rcurr, '\n', c->rbytes);
  				        if (!el) {
  				            if (c->rbytes > 1024) {
  				                /*
  				                 * We didn't have a '\n' in the first k. This _has_ to be a
  				                 * large multiget, if not we should just nuke the connection.
  				                 */
  				                char *ptr = c->rcurr;
  				                while (*ptr == ' ') { /* ignore leading whitespaces */
  				                    ++ptr;
  				                }

  				                if (ptr - c->rcurr > 100 ||
  				                    (strncmp(ptr, "get ", 4) && strncmp(ptr, "gets ", 5))) {

  				                    conn_set_state(c, conn_closing);
  				                    return 1;
  				                }
  				            }

  				            return 0;
  				        }
  				        cont = el + 1;
  				        if ((el - c->rcurr) > 1 && *(el - 1) == '\r') {
  				            el--;
  				        }
  				        *el = '\0';

  				        assert(cont <= (c->rcurr + c->rbytes));

  				        process_command(c, c->rcurr);

  				        c->rbytes -= (cont - c->rcurr);
  				        c->rcurr = cont;

  				        assert(c->rcurr <= (c->rbuf + c->rsize));
  				    }

  				    return 1;
  				}
  			</pre>      
  	        </div>
  	      </div>
  	    </div>
  	    <div class="panel panel-default">
  	      <div class="panel-heading">
  	        <h4 class="panel-title">
  	          <a data-toggle="collapse" data-parent="#accordion" href="#try_read_network">
  	            static enum try_read_result try_read_network(conn *c)
  	          </a>
  	        </h4>
  	      </div>
  	      <div id="try_read_network" class="panel-collapse collapse">
  	        <div class="panel-body">
  	          <pre>
  				  static enum try_read_result try_read_network(conn *c) {
  				      enum try_read_result gotdata = READ_NO_DATA_RECEIVED;
  				      int res;
  				      int num_allocs = 0;
  				      assert(c != NULL);

  				      if (c->rcurr != c->rbuf) {
  				          if (c->rbytes != 0) /* otherwise there's nothing to copy */
  				              memmove(c->rbuf, c->rcurr, c->rbytes);
  				          c->rcurr = c->rbuf;
  				      }

  				      while (1) {
  				          if (c->rbytes >= c->rsize) {
  				              if (num_allocs == 4) {
  				                  return gotdata;
  				              }
  				              ++num_allocs;
  				              char *new_rbuf = realloc(c->rbuf, c->rsize * 2);
  				              if (!new_rbuf) {
  				                  if (settings.verbose > 0)
  				                      fprintf(stderr, "Couldn't realloc input buffer\n");
  				                  c->rbytes = 0; /* ignore what we read */
  				                  out_string(c, "SERVER_ERROR out of memory reading request");
  				                  c->write_and_go = conn_closing;
  				                  return READ_MEMORY_ERROR;
  				              }
  				              c->rcurr = c->rbuf = new_rbuf;
  				              c->rsize *= 2;
  				          }

  				          int avail = c->rsize - c->rbytes;
  				          res = read(c->sfd, c->rbuf + c->rbytes, avail);
  				          if (res > 0) {
  				              pthread_mutex_lock(&c->thread->stats.mutex);
  				              c->thread->stats.bytes_read += res;
  				              pthread_mutex_unlock(&c->thread->stats.mutex);
  				              gotdata = READ_DATA_RECEIVED;
  				              c->rbytes += res;
  				              if (res == avail) {
  				                  continue;
  				              } else {
  				                  break;
  				              }
  				          }
  				          if (res == 0) {
  				              return READ_ERROR;
  				          }
  				          if (res == -1) {
  				              if (errno == EAGAIN || errno == EWOULDBLOCK) {
  				                  break;
  				              }
  				              return READ_ERROR;
  				          }
  				      }
  				      return gotdata;
  				  }
          	
  	          </pre>
  	        </div>
  	      </div>
  	    </div>
  	    <div class="panel panel-default">
  	      <div class="panel-heading">
  	        <h4 class="panel-title">
  	          <a data-toggle="collapse" data-parent="#accordion" href="#try_read_udp">
  	            static enum try_read_result try_read_udp(conn *c)
  	          </a>
  	        </h4>
  	      </div>
  	      <div id="try_read_udp" class="panel-collapse collapse">
  	        <div class="panel-body">
  	          <pre>
  				  /*
  				   * read a UDP request.
  				   */
  				  static enum try_read_result try_read_udp(conn *c) {
  				      int res;

  				      assert(c != NULL);

  				      c->request_addr_size = sizeof(c->request_addr);
  				      res = recvfrom(c->sfd, c->rbuf, c->rsize,
  				                     0, &c->request_addr, &c->request_addr_size);
  				      if (res > 8) {
  				          unsigned char *buf = (unsigned char *)c->rbuf;
  				          pthread_mutex_lock(&c->thread->stats.mutex);
  				          c->thread->stats.bytes_read += res;
  				          pthread_mutex_unlock(&c->thread->stats.mutex);

  				          /* Beginning of UDP packet is the request ID; save it. */
  				          c->request_id = buf[0] * 256 + buf[1];

  				          /* If this is a multi-packet request, drop it. */
  				          if (buf[4] != 0 || buf[5] != 1) {
  				              out_string(c, "SERVER_ERROR multi-packet request not supported");
  				              return READ_NO_DATA_RECEIVED;
  				          }

  				          /* Don't care about any of the rest of the header. */
  				          res -= 8;
  				          memmove(c->rbuf, c->rbuf + 8, res);

  				          c->rbytes = res;
  				          c->rcurr = c->rbuf;
  				          return READ_DATA_RECEIVED;
  				      }
  				      return READ_NO_DATA_RECEIVED;
  				  }
          	
  	          </pre>
  	        </div>
  	      </div>
  	    </div>
  	    <div class="panel panel-default">
  	      <div class="panel-heading">
  	        <h4 class="panel-title">
  	          <a data-toggle="collapse" data-parent="#accordion" href="#conn_set_state">
  	            static void conn_set_state(conn *c, enum conn_states state)
  	          </a>
  	        </h4>
  	      </div>
  	      <div id="conn_set_state" class="panel-collapse collapse">
  	        <div class="panel-body">
  	          <pre>
  				  /*
  				   * Sets a connection's current state in the state machine. Any special
  				   * processing that needs to happen on certain state transitions can
  				   * happen here.
  				   */
  				  static void conn_set_state(conn *c, enum conn_states state) {
  				      assert(c != NULL);
  				      assert(state >= conn_listening && state < conn_max_state);

  				      if (state != c->state) {
  				          if (settings.verbose > 2) {
  				              fprintf(stderr, "%d: going from %s to %s\n",
  				                      c->sfd, state_text(c->state),
  				                      state_text(state));
  				          }

  				          if (state == conn_write || state == conn_mwrite) {
  				              MEMCACHED_PROCESS_COMMAND_END(c->sfd, c->wbuf, c->wbytes);
  				          }
  				          c->state = state;
  				      }
  				  }
          	
  	          </pre>
  	        </div>
  	      </div>
  	    </div>
  	    <div class="panel panel-default">
  	      <div class="panel-heading">
  	        <h4 class="panel-title">
  	          <a data-toggle="collapse" data-parent="#accordion" href="#stats_init">
  	            static void stats_init(void)
  	          </a>
  	        </h4>
  	      </div>
  	      <div id="stats_init" class="panel-collapse collapse">
  	        <div class="panel-body">
  	          <pre>
  				  static void stats_init(void) {
  				      stats.curr_items = stats.total_items = stats.curr_conns = stats.total_conns = stats.conn_structs = 0;
  				      stats.get_cmds = stats.set_cmds = stats.get_hits = stats.get_misses = stats.evictions = stats.reclaimed = 0;
  				      stats.touch_cmds = stats.touch_misses = stats.touch_hits = stats.rejected_conns = 0;
  				      stats.curr_bytes = stats.listen_disabled_num = 0;
  				      stats.hash_power_level = stats.hash_bytes = stats.hash_is_expanding = 0;
  				      stats.expired_unfetched = stats.evicted_unfetched = 0;
  				      stats.slabs_moved = 0;
  				      stats.accepting_conns = true; /* assuming we start in this state. */
  				      stats.slab_reassign_running = false;

  				      /* make the time we started always be 2 seconds before we really
  				         did, so time(0) - time.started is never zero.  if so, things
  				         like 'settings.oldest_live' which act as booleans as well as
  				         values are now false in boolean context... */
  				      process_started = time(0) - 2;
  				      stats_prefix_init();
  				  }
          	
  	          </pre>
  	        </div>
  	      </div>
  	    </div>
  	    <div class="panel panel-default">
  	      <div class="panel-heading">
  	        <h4 class="panel-title">
  	          <a data-toggle="collapse" data-parent="#accordion" href="#server_stats">
  	            static void server_stats(ADD_STAT add_stats, conn *c)
  	          </a>
  	        </h4>
  	      </div>
  	      <div id="server_stats" class="panel-collapse collapse">
  	        <div class="panel-body">
  	          <pre>
  				  /* return server specific stats only */
  				  static void server_stats(ADD_STAT add_stats, conn *c) {
  				      pid_t pid = getpid();
  				      rel_time_t now = current_time;

  				      struct thread_stats thread_stats;
  				      threadlocal_stats_aggregate(&thread_stats);
  				      struct slab_stats slab_stats;
  				      slab_stats_aggregate(&thread_stats, &slab_stats);

  				  #ifndef WIN32
  				      struct rusage usage;
  				      getrusage(RUSAGE_SELF, &usage);
  				  #endif /* !WIN32 */

  				      STATS_LOCK();

  				      APPEND_STAT("pid", "%lu", (long)pid);
  				      APPEND_STAT("uptime", "%u", now);
  				      APPEND_STAT("time", "%ld", now + (long)process_started);
  				      APPEND_STAT("version", "%s", VERSION);
  				      APPEND_STAT("libevent", "%s", event_get_version());
  				      APPEND_STAT("pointer_size", "%d", (int)(8 * sizeof(void *)));

  				  #ifndef WIN32
  				      append_stat("rusage_user", add_stats, c, "%ld.%06ld",
  				                  (long)usage.ru_utime.tv_sec,
  				                  (long)usage.ru_utime.tv_usec);
  				      append_stat("rusage_system", add_stats, c, "%ld.%06ld",
  				                  (long)usage.ru_stime.tv_sec,
  				                  (long)usage.ru_stime.tv_usec);
  				  #endif /* !WIN32 */

  				      APPEND_STAT("curr_connections", "%u", stats.curr_conns - 1);
  				      APPEND_STAT("total_connections", "%u", stats.total_conns);
  				      if (settings.maxconns_fast) {
  				          APPEND_STAT("rejected_connections", "%llu", (unsigned long long)stats.rejected_conns);
  				      }
  				      APPEND_STAT("connection_structures", "%u", stats.conn_structs);
  				      APPEND_STAT("reserved_fds", "%u", stats.reserved_fds);
  				      APPEND_STAT("cmd_get", "%llu", (unsigned long long)thread_stats.get_cmds);
  				      APPEND_STAT("cmd_set", "%llu", (unsigned long long)slab_stats.set_cmds);
  				      APPEND_STAT("cmd_flush", "%llu", (unsigned long long)thread_stats.flush_cmds);
  				      APPEND_STAT("cmd_touch", "%llu", (unsigned long long)thread_stats.touch_cmds);
  				      APPEND_STAT("get_hits", "%llu", (unsigned long long)slab_stats.get_hits);
  				      APPEND_STAT("get_misses", "%llu", (unsigned long long)thread_stats.get_misses);
  				      APPEND_STAT("delete_misses", "%llu", (unsigned long long)thread_stats.delete_misses);
  				      APPEND_STAT("delete_hits", "%llu", (unsigned long long)slab_stats.delete_hits);
  				      APPEND_STAT("incr_misses", "%llu", (unsigned long long)thread_stats.incr_misses);
  				      APPEND_STAT("incr_hits", "%llu", (unsigned long long)slab_stats.incr_hits);
  				      APPEND_STAT("decr_misses", "%llu", (unsigned long long)thread_stats.decr_misses);
  				      APPEND_STAT("decr_hits", "%llu", (unsigned long long)slab_stats.decr_hits);
  				      APPEND_STAT("cas_misses", "%llu", (unsigned long long)thread_stats.cas_misses);
  				      APPEND_STAT("cas_hits", "%llu", (unsigned long long)slab_stats.cas_hits);
  				      APPEND_STAT("cas_badval", "%llu", (unsigned long long)slab_stats.cas_badval);
  				      APPEND_STAT("touch_hits", "%llu", (unsigned long long)slab_stats.touch_hits);
  				      APPEND_STAT("touch_misses", "%llu", (unsigned long long)thread_stats.touch_misses);
  				      APPEND_STAT("auth_cmds", "%llu", (unsigned long long)thread_stats.auth_cmds);
  				      APPEND_STAT("auth_errors", "%llu", (unsigned long long)thread_stats.auth_errors);
  				      APPEND_STAT("bytes_read", "%llu", (unsigned long long)thread_stats.bytes_read);
  				      APPEND_STAT("bytes_written", "%llu", (unsigned long long)thread_stats.bytes_written);
  				      APPEND_STAT("limit_maxbytes", "%llu", (unsigned long long)settings.maxbytes);
  				      APPEND_STAT("accepting_conns", "%u", stats.accepting_conns);
  				      APPEND_STAT("listen_disabled_num", "%llu", (unsigned long long)stats.listen_disabled_num);
  				      APPEND_STAT("threads", "%d", settings.num_threads);
  				      APPEND_STAT("conn_yields", "%llu", (unsigned long long)thread_stats.conn_yields);
  				      APPEND_STAT("hash_power_level", "%u", stats.hash_power_level);
  				      APPEND_STAT("hash_bytes", "%llu", (unsigned long long)stats.hash_bytes);
  				      APPEND_STAT("hash_is_expanding", "%u", stats.hash_is_expanding);
  				      if (settings.slab_reassign) {
  				          APPEND_STAT("slab_reassign_running", "%u", stats.slab_reassign_running);
  				          APPEND_STAT("slabs_moved", "%llu", stats.slabs_moved);
  				      }
  				      STATS_UNLOCK();
  				  }
          	
  	          </pre>
  	        </div>
  	      </div>
  	    </div>
  	    <div class="panel panel-default">
  	      <div class="panel-heading">
  	        <h4 class="panel-title">
  	          <a data-toggle="collapse" data-parent="#accordion" href="#process_stat_settings">
  	            static void process_stat_settings(ADD_STAT add_stats, void *c)
  	          </a>
  	        </h4>
  	      </div>
  	      <div id="process_stat_settings" class="panel-collapse collapse">
  	        <div class="panel-body">
  	          <pre>
  				  static void process_stat_settings(ADD_STAT add_stats, void *c) {
  				      assert(add_stats);
  				      APPEND_STAT("maxbytes", "%u", (unsigned int)settings.maxbytes);
  				      APPEND_STAT("maxconns", "%d", settings.maxconns);
  				      APPEND_STAT("tcpport", "%d", settings.port);
  				      APPEND_STAT("udpport", "%d", settings.udpport);
  				      APPEND_STAT("inter", "%s", settings.inter ? settings.inter : "NULL");
  				      APPEND_STAT("verbosity", "%d", settings.verbose);
  				      APPEND_STAT("oldest", "%lu", (unsigned long)settings.oldest_live);
  				      APPEND_STAT("evictions", "%s", settings.evict_to_free ? "on" : "off");
  				      APPEND_STAT("domain_socket", "%s",
  				                  settings.socketpath ? settings.socketpath : "NULL");
  				      APPEND_STAT("umask", "%o", settings.access);
  				      APPEND_STAT("growth_factor", "%.2f", settings.factor);
  				      APPEND_STAT("chunk_size", "%d", settings.chunk_size);
  				      APPEND_STAT("num_threads", "%d", settings.num_threads);
  				      APPEND_STAT("num_threads_per_udp", "%d", settings.num_threads_per_udp);
  				      APPEND_STAT("stat_key_prefix", "%c", settings.prefix_delimiter);
  				      APPEND_STAT("detail_enabled", "%s",
  				                  settings.detail_enabled ? "yes" : "no");
  				      APPEND_STAT("reqs_per_event", "%d", settings.reqs_per_event);
  				      APPEND_STAT("cas_enabled", "%s", settings.use_cas ? "yes" : "no");
  				      APPEND_STAT("tcp_backlog", "%d", settings.backlog);
  				      APPEND_STAT("binding_protocol", "%s",
  				                  prot_text(settings.binding_protocol));
  				      APPEND_STAT("auth_enabled_sasl", "%s", settings.sasl ? "yes" : "no");
  				      APPEND_STAT("item_size_max", "%d", settings.item_size_max);
  				      APPEND_STAT("maxconns_fast", "%s", settings.maxconns_fast ? "yes" : "no");
  				      APPEND_STAT("hashpower_init", "%d", settings.hashpower_init);
  				      APPEND_STAT("slab_reassign", "%s", settings.slab_reassign ? "yes" : "no");
  				      APPEND_STAT("slab_automove", "%d", settings.slab_automove);
  				  }
          	
  	          </pre>
  	        </div>
  	      </div>
  	    </div>
  	    <div class="panel panel-default">
  	      <div class="panel-heading">
  	        <h4 class="panel-title">
  	          <a data-toggle="collapse" data-parent="#accordion" href="#settings_init">
  	            static void settings_init(void)
  	          </a>
  	        </h4>
  	      </div>
  	      <div id="settings_init" class="panel-collapse collapse">
  	        <div class="panel-body">
  	          <pre>
  				  static void settings_init(void) {
  				      settings.use_cas = true;
  				      settings.access = 0700;
  				      settings.port = 11211;
  				      settings.udpport = 11211;
  				      /* By default this string should be NULL for getaddrinfo() */
  				      settings.inter = NULL;
  				      settings.maxbytes = 64 * 1024 * 1024; /* default is 64MB */
  				      settings.maxconns = 1024;         /* to limit connections-related memory to about 5MB */
  				      settings.verbose = 0;
  				      settings.oldest_live = 0;
  				      settings.evict_to_free = 1;       /* push old items out of cache when memory runs out */
  				      settings.socketpath = NULL;       /* by default, not using a unix socket */
  				      settings.factor = 1.25;
  				      settings.chunk_size = 48;         /* space for a modest key and value */
  				      settings.num_threads = 4;         /* N workers */
  				      settings.num_threads_per_udp = 0;
  				      settings.prefix_delimiter = ':';
  				      settings.detail_enabled = 0;
  				      settings.reqs_per_event = 20;
  				      settings.backlog = 1024;
  				      settings.binding_protocol = negotiating_prot;
  				      settings.item_size_max = 1024 * 1024; /* The famous 1MB upper limit. */
  				      settings.maxconns_fast = false;
  				      settings.hashpower_init = 0;
  				      settings.slab_reassign = false;
  				      settings.slab_automove = 0;
  				      settings.shutdown_command = false;
  				  }
          	
  	          </pre>
  	        </div>
  	      </div>
  	    </div>
  	    <div class="panel panel-default">
  	      <div class="panel-heading">
  	        <h4 class="panel-title">
  	          <a data-toggle="collapse" data-parent="#accordion" href="#event_handler">
  	            void event_handler(const int fd, const short which, void *arg)
  	          </a>
  	        </h4>
  	      </div>
  	      <div id="event_handler" class="panel-collapse collapse">
  	        <div class="panel-body">
  	          <pre>
  				  void event_handler(const int fd, const short which, void *arg) {
  				      conn *c;

  				      c = (conn *)arg;
  				      assert(c != NULL);

  				      c->which = which;

  				      /* sanity */
  				      if (fd != c->sfd) {
  				          if (settings.verbose > 0)
  				              fprintf(stderr, "Catastrophic: event fd doesn't match conn fd!\n");
  				          conn_close(c);
  				          return;
  				      }

  				      drive_machine(c);

  				      /* wait for next event */
  				      return;
  				  }
          	
  	          </pre>
  	        </div>
  	      </div>
  	    </div>
  	    <div class="panel panel-default">
  	      <div class="panel-heading">
  	        <h4 class="panel-title">
  	          <a data-toggle="collapse" data-parent="#accordion" href="#conn_close">
  	            static void conn_close(conn *c)
  	          </a>
  	        </h4>
  	      </div>
  	      <div id="conn_close" class="panel-collapse collapse">
  	        <div class="panel-body">
  	          <pre>
  				  static void conn_close(conn *c) {
  				      assert(c != NULL);

  				      /* delete the event, the socket and the conn */
  				      event_del(&c->event);

  				      if (settings.verbose > 1)
  				          fprintf(stderr, "<%d connection closed.\n", c->sfd);

  				      MEMCACHED_CONN_RELEASE(c->sfd);
  				      close(c->sfd);
  				      pthread_mutex_lock(&conn_lock);
  				      allow_new_conns = true;
  				      pthread_mutex_unlock(&conn_lock);
  				      conn_cleanup(c);

  				      /* if the connection has big buffers, just free it */
  				      if (c->rsize > READ_BUFFER_HIGHWAT || conn_add_to_freelist(c)) {
  				          conn_free(c);
  				      }

  				      STATS_LOCK();
  				      stats.curr_conns--;
  				      STATS_UNLOCK();

  				      return;
  				  }
          	
  	          </pre>
  	        </div>
  	      </div>
  	    </div>
  	    <div class="panel panel-default">
  	      <div class="panel-heading">
  	        <h4 class="panel-title">
  	          <a data-toggle="collapse" data-parent="#accordion" href="#conn_init">
  	            static void conn_init(void)
  	          </a>
  	        </h4>
  	      </div>
  	      <div id="conn_init" class="panel-collapse collapse">
  	        <div class="panel-body">
  	          <pre>
  				  static void conn_init(void) {
  				      freetotal = 200;
  				      freecurr = 0;
  				      if ((freeconns = calloc(freetotal, sizeof(conn *))) == NULL) {
  				          fprintf(stderr, "Failed to allocate connection structures\n");
  				      }
  				      return;
  				  }
  	          </pre>
  	        </div>
  	      </div>
  	    </div>
  	    <div class="panel panel-default">
  	      <div class="panel-heading">
  	        <h4 class="panel-title">
  	          <a data-toggle="collapse" data-parent="#accordion" href="#update_event">
  	            static bool update_event(conn *c, const int new_flags)
  	          </a>
  	        </h4>
  	      </div>
  	      <div id="update_event" class="panel-collapse collapse">
  	        <div class="panel-body">
  	          <pre>
  				  static bool update_event(conn *c, const int new_flags) {
  				      assert(c != NULL);

  				      struct event_base *base = c->event.ev_base;
  				      if (c->ev_flags == new_flags)
  				          return true;
  				      if (event_del(&c->event) == -1) return false;
  				      event_set(&c->event, c->sfd, new_flags, event_handler, (void *)c);
  				      event_base_set(base, &c->event);
  				      c->ev_flags = new_flags;
  				      if (event_add(&c->event, 0) == -1) return false;
  				      return true;
  				  }
          	
  	          </pre>
  	        </div>
  	      </div>
  	    </div>
  	    <div class="panel panel-default">
  	      <div class="panel-heading">
  	        <h4 class="panel-title">
  	          <a data-toggle="collapse" data-parent="#accordion" href="#complete_nread">
  	            static void complete_nread(conn *c)
  	          </a>
  	        </h4>
  	      </div>
  	      <div id="complete_nread" class="panel-collapse collapse">
  	        <div class="panel-body">
  	          <pre>
  				  static void complete_nread(conn *c) {
  				      assert(c != NULL);
  				      assert(c->protocol == ascii_prot
  				             || c->protocol == binary_prot);

  				      if (c->protocol == ascii_prot) {
  				          complete_nread_ascii(c);
  				      } else if (c->protocol == binary_prot) {
  				          complete_nread_binary(c);
  				      }
  				  }
  	          </pre>
  	        </div>
  	      </div>
  	    </div>
  	    <div class="panel panel-default">
  	      <div class="panel-heading">
  	        <h4 class="panel-title">
  	          <a data-toggle="collapse" data-parent="#accordion" href="#process_command">
  	            static void process_command(conn *c, char *command) 
  	          </a>
  	        </h4>
  	      </div>
  	      <div id="process_command" class="panel-collapse collapse">
  	        <div class="panel-body">
  	          <pre>
  				  static void process_command(conn *c, char *command) {

  				      token_t tokens[MAX_TOKENS];
  				      size_t ntokens;
  				      int comm;

  				      assert(c != NULL);

  				      MEMCACHED_PROCESS_COMMAND_START(c->sfd, c->rcurr, c->rbytes);

  				      if (settings.verbose > 1)
  				          fprintf(stderr, "<%d %s\n", c->sfd, command);

  				      /*
  				       * for commands set/add/replace, we build an item and read the data
  				       * directly into it, then continue in nread_complete().
  				       */

  				      c->msgcurr = 0;
  				      c->msgused = 0;
  				      c->iovused = 0;
  				      if (add_msghdr(c) != 0) {
  				          out_string(c, "SERVER_ERROR out of memory preparing response");
  				          return;
  				      }

  				      ntokens = tokenize_command(command, tokens, MAX_TOKENS);
  				      if (ntokens >= 3 &&
  				          ((strcmp(tokens[COMMAND_TOKEN].value, "get") == 0) ||
  				           (strcmp(tokens[COMMAND_TOKEN].value, "bget") == 0))) {

  				          process_get_command(c, tokens, ntokens, false);

  				      } else if ((ntokens == 6 || ntokens == 7) &&
  				                 ((strcmp(tokens[COMMAND_TOKEN].value, "add") == 0 && (comm = NREAD_ADD)) ||
  				                  (strcmp(tokens[COMMAND_TOKEN].value, "set") == 0 && (comm = NREAD_SET)) ||
  				                  (strcmp(tokens[COMMAND_TOKEN].value, "replace") == 0 && (comm = NREAD_REPLACE)) ||
  				                  (strcmp(tokens[COMMAND_TOKEN].value, "prepend") == 0 && (comm = NREAD_PREPEND)) ||
  				                  (strcmp(tokens[COMMAND_TOKEN].value, "append") == 0 && (comm = NREAD_APPEND)) )) {

  				          process_update_command(c, tokens, ntokens, comm, false);

  				      } else if ((ntokens == 7 || ntokens == 8) && (strcmp(tokens[COMMAND_TOKEN].value, "cas") == 0 && (comm = NREAD_CAS))) {

  				          process_update_command(c, tokens, ntokens, comm, true);

  				      } else if ((ntokens == 4 || ntokens == 5) && (strcmp(tokens[COMMAND_TOKEN].value, "incr") == 0)) {

  				          process_arithmetic_command(c, tokens, ntokens, 1);

  				      } else if (ntokens >= 3 && (strcmp(tokens[COMMAND_TOKEN].value, "gets") == 0)) {

  				          process_get_command(c, tokens, ntokens, true);

  				      } else if ((ntokens == 4 || ntokens == 5) && (strcmp(tokens[COMMAND_TOKEN].value, "decr") == 0)) {

  				          process_arithmetic_command(c, tokens, ntokens, 0);

  				      } else if (ntokens >= 3 && ntokens <= 5 && (strcmp(tokens[COMMAND_TOKEN].value, "delete") == 0)) {

  				          process_delete_command(c, tokens, ntokens);

  				      } else if ((ntokens == 4 || ntokens == 5) && (strcmp(tokens[COMMAND_TOKEN].value, "touch") == 0)) {

  				          process_touch_command(c, tokens, ntokens);

  				      } else if (ntokens >= 2 && (strcmp(tokens[COMMAND_TOKEN].value, "stats") == 0)) {

  				          process_stat(c, tokens, ntokens);

  				      } else if (ntokens >= 2 && ntokens <= 4 && (strcmp(tokens[COMMAND_TOKEN].value, "flush_all") == 0)) {
  				          time_t exptime = 0;

  				          set_noreply_maybe(c, tokens, ntokens);

  				          pthread_mutex_lock(&c->thread->stats.mutex);
  				          c->thread->stats.flush_cmds++;
  				          pthread_mutex_unlock(&c->thread->stats.mutex);

  				          if(ntokens == (c->noreply ? 3 : 2)) {
  				              settings.oldest_live = current_time - 1;
  				              item_flush_expired();
  				              out_string(c, "OK");
  				              return;
  				          }

  				          exptime = strtol(tokens[1].value, NULL, 10);
  				          if(errno == ERANGE) {
  				              out_string(c, "CLIENT_ERROR bad command line format");
  				              return;
  				          }

  				          /*
  				            If exptime is zero realtime() would return zero too, and
  				            realtime(exptime) - 1 would overflow to the max unsigned
  				            value.  So we process exptime == 0 the same way we do when
  				            no delay is given at all.
  				          */
  				          if (exptime > 0)
  				              settings.oldest_live = realtime(exptime) - 1;
  				          else /* exptime == 0 */
  				              settings.oldest_live = current_time - 1;
  				          item_flush_expired();
  				          out_string(c, "OK");
  				          return;

  				      } else if (ntokens == 2 && (strcmp(tokens[COMMAND_TOKEN].value, "version") == 0)) {

  				          out_string(c, "VERSION " VERSION);

  				      } else if (ntokens == 2 && (strcmp(tokens[COMMAND_TOKEN].value, "quit") == 0)) {

  				          conn_set_state(c, conn_closing);

  				      } else if (ntokens == 2 && (strcmp(tokens[COMMAND_TOKEN].value, "shutdown") == 0)) {

  				          if (settings.shutdown_command) {
  				              conn_set_state(c, conn_closing);
  				              raise(SIGINT);
  				          } else {
  				              out_string(c, "ERROR: shutdown not enabled");
  				          }

  				      } else if (ntokens > 1 && strcmp(tokens[COMMAND_TOKEN].value, "slabs") == 0) {
  				          if (ntokens == 5 && strcmp(tokens[COMMAND_TOKEN + 1].value, "reassign") == 0) {
  				              int src, dst, rv;

  				              if (settings.slab_reassign == false) {
  				                  out_string(c, "CLIENT_ERROR slab reassignment disabled");
  				                  return;
  				              }

  				              src = strtol(tokens[2].value, NULL, 10);
  				              dst = strtol(tokens[3].value, NULL, 10);

  				              if (errno == ERANGE) {
  				                  out_string(c, "CLIENT_ERROR bad command line format");
  				                  return;
  				              }

  				              rv = slabs_reassign(src, dst);
  				              switch (rv) {
  				              case REASSIGN_OK:
  				                  out_string(c, "OK");
  				                  break;
  				              case REASSIGN_RUNNING:
  				                  out_string(c, "BUSY currently processing reassign request");
  				                  break;
  				              case REASSIGN_BADCLASS:
  				                  out_string(c, "BADCLASS invalid src or dst class id");
  				                  break;
  				              case REASSIGN_NOSPARE:
  				                  out_string(c, "NOSPARE source class has no spare pages");
  				                  break;
  				              case REASSIGN_SRC_DST_SAME:
  				                  out_string(c, "SAME src and dst class are identical");
  				                  break;
  				              }
  				              return;
  				          } else if (ntokens == 4 &&
  				              (strcmp(tokens[COMMAND_TOKEN + 1].value, "automove") == 0)) {
  				              process_slabs_automove_command(c, tokens, ntokens);
  				          } else {
  				              out_string(c, "ERROR");
  				          }
  				      } else if ((ntokens == 3 || ntokens == 4) && (strcmp(tokens[COMMAND_TOKEN].value, "verbosity") == 0)) {
  				          process_verbosity_command(c, tokens, ntokens);
  				      } else {
  				          out_string(c, "ERROR");
  				      }
  				      return;
  				  }
          	
  	          </pre>
  	        </div>
  	      </div>
  	    </div>
  	    <div class="panel panel-default">
  	      <div class="panel-heading">
  	        <h4 class="panel-title">
  	          <a data-toggle="collapse" data-parent="#accordion" href="#write_and_free">
  	            static void write_and_free(conn *c, char *buf, int bytes)
  	          </a>
  	        </h4>
  	      </div>
  	      <div id="write_and_free" class="panel-collapse collapse">
  	        <div class="panel-body">
  	          <pre>
  				  /* set up a connection to write a buffer then free it, used for stats */
  				  static void write_and_free(conn *c, char *buf, int bytes) {
  				      if (buf) {
  				          c->write_and_free = buf;
  				          c->wcurr = buf;
  				          c->wbytes = bytes;
  				          conn_set_state(c, conn_write);
  				          c->write_and_go = conn_new_cmd;
  				      } else {
  				          out_string(c, "SERVER_ERROR out of memory writing stats");
  				      }
  				  }
  	          </pre>
  	        </div>
  	      </div>
  	    </div>
  	    <div class="panel panel-default">
  	      <div class="panel-heading">
  	        <h4 class="panel-title">
  	          <a data-toggle="collapse" data-parent="#accordion" href="#ensure_iov_space">
  	            static int ensure_iov_space(conn *c)
  	          </a>
  	        </h4>
  	      </div>
  	      <div id="ensure_iov_space" class="panel-collapse collapse">
  	        <div class="panel-body">
  	          <pre>
  				  /*
  				   * Ensures that there is room for another struct iovec in a connection's
  				   * iov list.
  				   *
  				   * Returns 0 on success, -1 on out-of-memory.
  				   */
  				  static int ensure_iov_space(conn *c) {
  				      assert(c != NULL);

  				      if (c->iovused >= c->iovsize) {
  				          int i, iovnum;
  				          struct iovec *new_iov = (struct iovec *)realloc(c->iov,
  				                                  (c->iovsize * 2) * sizeof(struct iovec));
  				          if (! new_iov)
  				              return -1;
  				          c->iov = new_iov;
  				          c->iovsize *= 2;

  				          /* Point all the msghdr structures at the new list. */
  				          for (i = 0, iovnum = 0; i < c->msgused; i++) {
  				              c->msglist[i].msg_iov = &c->iov[iovnum];
  				              iovnum += c->msglist[i].msg_iovlen;
  				          }
  				      }

  				      return 0;
  				  }
          	
  	          </pre>
  	        </div>
  	      </div>
  	    </div>
  	    <div class="panel panel-default">
  	      <div class="panel-heading">
  	        <h4 class="panel-title">
  	          <a data-toggle="collapse" data-parent="#accordion" href="#add_iov">
  	            static int add_iov(conn *c, const void *buf, int len)
  	          </a>
  	        </h4>
  	      </div>
  	      <div id="add_iov" class="panel-collapse collapse">
  	        <div class="panel-body">
  	          <pre>
  				  /*
  				   * Adds data to the list of pending data that will be written out to a
  				   * connection.
  				   *
  				   * Returns 0 on success, -1 on out-of-memory.
  				   */

  				  static int add_iov(conn *c, const void *buf, int len) {
  				      struct msghdr *m;
  				      int leftover;
  				      bool limit_to_mtu;

  				      assert(c != NULL);

  				      do {
  				          m = &c->msglist[c->msgused - 1];

  				          /*
  				           * Limit UDP packets, and the first payloads of TCP replies, to
  				           * UDP_MAX_PAYLOAD_SIZE bytes.
  				           */
  				          limit_to_mtu = IS_UDP(c->transport) || (1 == c->msgused);

  				          /* We may need to start a new msghdr if this one is full. */
  				          if (m->msg_iovlen == IOV_MAX ||
  				              (limit_to_mtu && c->msgbytes >= UDP_MAX_PAYLOAD_SIZE)) {
  				              add_msghdr(c);
  				              m = &c->msglist[c->msgused - 1];
  				          }

  				          if (ensure_iov_space(c) != 0)
  				              return -1;

  				          /* If the fragment is too big to fit in the datagram, split it up */
  				          if (limit_to_mtu && len + c->msgbytes > UDP_MAX_PAYLOAD_SIZE) {
  				              leftover = len + c->msgbytes - UDP_MAX_PAYLOAD_SIZE;
  				              len -= leftover;
  				          } else {
  				              leftover = 0;
  				          }

  				          m = &c->msglist[c->msgused - 1];
  				          m->msg_iov[m->msg_iovlen].iov_base = (void *)buf;
  				          m->msg_iov[m->msg_iovlen].iov_len = len;

  				          c->msgbytes += len;
  				          c->iovused++;
  				          m->msg_iovlen++;

  				          buf = ((char *)buf) + len;
  				          len = leftover;
  				      } while (leftover > 0);

  				      return 0;
  				  }
          	
  	          </pre>
  	        </div>
  	      </div>
  	    </div>
  	    <div class="panel panel-default">
  	      <div class="panel-heading">
  	        <h4 class="panel-title">
  	          <a data-toggle="collapse" data-parent="#accordion" href="#add_msghdr">
  	            static int add_msghdr(conn *c)
  	          </a>
  	        </h4>
  	      </div>
  	      <div id="add_msghdr" class="panel-collapse collapse">
  	        <div class="panel-body">
  	          <pre>
  				  /*
  				   * Adds a message header to a connection.
  				   *
  				   * Returns 0 on success, -1 on out-of-memory.
  				   */
  				  static int add_msghdr(conn *c)
  				  {
  				      struct msghdr *msg;

  				      assert(c != NULL);

  				      if (c->msgsize == c->msgused) {
  				          msg = realloc(c->msglist, c->msgsize * 2 * sizeof(struct msghdr));
  				          if (! msg)
  				              return -1;
  				          c->msglist = msg;
  				          c->msgsize *= 2;
  				      }

  				      msg = c->msglist + c->msgused;

  				      /* this wipes msg_iovlen, msg_control, msg_controllen, and
  				         msg_flags, the last 3 of which aren't defined on solaris: */
  				      memset(msg, 0, sizeof(struct msghdr));

  				      msg->msg_iov = &c->iov[c->iovused];

  				      if (c->request_addr_size > 0) {
  				          msg->msg_name = &c->request_addr;
  				          msg->msg_namelen = c->request_addr_size;
  				      }

  				      c->msgbytes = 0;
  				      c->msgused++;

  				      if (IS_UDP(c->transport)) {
  				          /* Leave room for the UDP header, which we'll fill in later. */
  				          return add_iov(c, NULL, UDP_HEADER_SIZE);
  				      }

  				      return 0;
  				  }
          	
  	          </pre>
  	        </div>
  	      </div>
  	    </div>
  	    <div class="panel panel-default">
  	      <div class="panel-heading">
  	        <h4 class="panel-title">
  	          <a data-toggle="collapse" data-parent="#accordion" href="#conn_free">
  	            void conn_free(conn *c) 
  	          </a>
  	        </h4>
  	      </div>
  	      <div id="conn_free" class="panel-collapse collapse">
  	        <div class="panel-body">
  	          <pre>
  				  /*
  				   * Frees a connection.
  				   */
  				  void conn_free(conn *c) {
  				      if (c) {
  				          MEMCACHED_CONN_DESTROY(c);
  				          if (c->hdrbuf)
  				              free(c->hdrbuf);
  				          if (c->msglist)
  				              free(c->msglist);
  				          if (c->rbuf)
  				              free(c->rbuf);
  				          if (c->wbuf)
  				              free(c->wbuf);
  				          if (c->ilist)
  				              free(c->ilist);
  				          if (c->suffixlist)
  				              free(c->suffixlist);
  				          if (c->iov)
  				              free(c->iov);
  				          free(c);
  				      }
  				  }
          	
  	          </pre>
  	        </div>
  	      </div>
  	    </div>
  	    <div class="panel panel-default">
  	      <div class="panel-heading">
  	        <h4 class="panel-title">
  	          <a data-toggle="collapse" data-parent="#accordion" href="#maxconns_handler">
  	            static void maxconns_handler(const int fd, const short which, void *arg)
  	          </a>
  	        </h4>
  	      </div>
  	      <div id="maxconns_handler" class="panel-collapse collapse">
  	        <div class="panel-body">
  	          <pre>
  				  static void maxconns_handler(const int fd, const short which, void *arg) {
  				      struct timeval t = {.tv_sec = 0, .tv_usec = 10000};

  				      if (fd == -42 || allow_new_conns == false) {
  				          /* reschedule in 10ms if we need to keep polling */
  				          evtimer_set(&maxconnsevent, maxconns_handler, 0);
  				          event_base_set(main_base, &maxconnsevent);
  				          evtimer_add(&maxconnsevent, &t);
  				      } else {
  				          evtimer_del(&maxconnsevent);
  				          accept_new_conns(true);
  				      }
  				  }
  	          </pre>
  	        </div>
  	      </div>
  	    </div>
  	    <div class="panel panel-default">
  	      <div class="panel-heading">
  	        <h4 class="panel-title">
  	          <a data-toggle="collapse" data-parent="#accordion" href="#realtime">
  	            static rel_time_t realtime(const time_t exptime)
  	          </a>
  	        </h4>
  	      </div>
  	      <div id="realtime" class="panel-collapse collapse">
  	        <div class="panel-body">
  	          <pre>
  				  /*
  				   * given time value that's either unix time or delta from current unix time, return
  				   * unix time. Use the fact that delta can't exceed one month (and real time value can't
  				   * be that low).
  				   */
  				  static rel_time_t realtime(const time_t exptime) {
  				      /* no. of seconds in 30 days - largest possible delta exptime */

  				      if (exptime == 0) return 0; /* 0 means never expire */

  				      if (exptime > REALTIME_MAXDELTA) {
  				          /* if item expiration is at/before the server started, give it an
  				             expiration time of 1 second after the server started.
  				             (because 0 means don't expire).  without this, we'd
  				             underflow and wrap around to some large value way in the
  				             future, effectively making items expiring in the past
  				             really expiring never */
  				          if (exptime <= process_started)
  				              return (rel_time_t)1;
  				          return (rel_time_t)(exptime - process_started);
  				      } else {
  				          return (rel_time_t)(exptime + current_time);
  				      }
  				  }
          	
  	          </pre>
  	        </div>
  	      </div>
  	    </div>
  	    <div class="panel panel-default">
  	      <div class="panel-heading">
  	        <h4 class="panel-title">
  	          <a data-toggle="collapse" data-parent="#accordion" href="#stats_reset">
  	            static void stats_reset(void)
  	          </a>
  	        </h4>
  	      </div>
  	      <div id="stats_reset" class="panel-collapse collapse">
  	        <div class="panel-body">
  	          <pre>
  				  static void stats_reset(void) {
  				      STATS_LOCK();
  				      stats.total_items = stats.total_conns = 0;
  				      stats.rejected_conns = 0;
  				      stats.evictions = 0;
  				      stats.reclaimed = 0;
  				      stats.listen_disabled_num = 0;
  				      stats_prefix_clear();
  				      STATS_UNLOCK();
  				      threadlocal_stats_reset();
  				      item_stats_reset();
  				  }
          	
  	          </pre>
  	        </div>
  	      </div>
  	    </div>
  	    <div class="panel panel-default">
  	      <div class="panel-heading">
  	        <h4 class="panel-title">
  	          <a data-toggle="collapse" data-parent="#accordion" href="#add_msghdr">
  	            static int add_msghdr(conn *c)
  	          </a>
  	        </h4>
  	      </div>
  	      <div id="add_msghdr" class="panel-collapse collapse">
  	        <div class="panel-body">
  	          <pre>
  				  /*
  				   * Adds a message header to a connection.
  				   *
  				   * Returns 0 on success, -1 on out-of-memory.
  				   */
  				  static int add_msghdr(conn *c)
  				  {
  				      struct msghdr *msg;

  				      assert(c != NULL);

  				      if (c->msgsize == c->msgused) {
  				          msg = realloc(c->msglist, c->msgsize * 2 * sizeof(struct msghdr));
  				          if (! msg)
  				              return -1;
  				          c->msglist = msg;
  				          c->msgsize *= 2;
  				      }

  				      msg = c->msglist + c->msgused;

  				      /* this wipes msg_iovlen, msg_control, msg_controllen, and
  				         msg_flags, the last 3 of which aren't defined on solaris: */
  				      memset(msg, 0, sizeof(struct msghdr));

  				      msg->msg_iov = &c->iov[c->iovused];

  				      if (c->request_addr_size > 0) {
  				          msg->msg_name = &c->request_addr;
  				          msg->msg_namelen = c->request_addr_size;
  				      }

  				      c->msgbytes = 0;
  				      c->msgused++;

  				      if (IS_UDP(c->transport)) {
  				          /* Leave room for the UDP header, which we'll fill in later. */
  				          return add_iov(c, NULL, UDP_HEADER_SIZE);
  				      }

  				      return 0;
  				  }
          	
  	          </pre>
  	        </div>
  	      </div>
  	    </div>
  	    <div class="panel panel-default">
  	      <div class="panel-heading">
  	        <h4 class="panel-title">
  	          <a data-toggle="collapse" data-parent="#accordion" href="#conn_from_freelist">
  	            conn *conn_from_freelist()
  	          </a>
  	        </h4>
  	      </div>
  	      <div id="conn_from_freelist" class="panel-collapse collapse">
  	        <div class="panel-body">
  	          <pre>
  				  /*
  				   * Returns a connection from the freelist, if any.
  				   */
  				  conn *conn_from_freelist() {
  				      conn *c;

  				      pthread_mutex_lock(&conn_lock);
  				      if (freecurr > 0) {
  				          c = freeconns[--freecurr];
  				      } else {
  				          c = NULL;
  				      }
  				      pthread_mutex_unlock(&conn_lock);

  				      return c;
  				  }
  	          </pre>
  	        </div>
  	      </div>
  	    </div>
  	    <div class="panel panel-default">
  	      <div class="panel-heading">
  	        <h4 class="panel-title">
  	          <a data-toggle="collapse" data-parent="#accordion" href="#conn_add_to_freelist">
  	            bool conn_add_to_freelist(conn *c)
  	          </a>
  	        </h4>
  	      </div>
  	      <div id="conn_add_to_freelist" class="panel-collapse collapse">
  	        <div class="panel-body">
  	          <pre>
  				  /*
  				   * Adds a connection to the freelist. 0 = success.
  				   */
  				  bool conn_add_to_freelist(conn *c) {
  				      bool ret = true;
  				      pthread_mutex_lock(&conn_lock);
  				      if (freecurr < freetotal) {
  				          freeconns[freecurr++] = c;
  				          ret = false;
  				      } else {
  				          /* try to enlarge free connections array */
  				          size_t newsize = freetotal * 2;
  				          conn **new_freeconns = realloc(freeconns, sizeof(conn *) * newsize);
  				          if (new_freeconns) {
  				              freetotal = newsize;
  				              freeconns = new_freeconns;
  				              freeconns[freecurr++] = c;
  				              ret = false;
  				          }
  				      }
  				      pthread_mutex_unlock(&conn_lock);
  				      return ret;
  				  }
          	
  	          </pre>
  	        </div>
  	      </div>
  	    </div>
  	    <div class="panel panel-default">
  	      <div class="panel-heading">
  	        <h4 class="panel-title">
  	          <a data-toggle="collapse" data-parent="#accordion" href="#prot_text">
  	            static const char *prot_text(enum protocol prot) 
  	          </a>
  	        </h4>
  	      </div>
  	      <div id="prot_text" class="panel-collapse collapse">
  	        <div class="panel-body">
  	          <pre>
  				  static const char *prot_text(enum protocol prot) {
  				      char *rv = "unknown";
  				      switch(prot) {
  				          case ascii_prot:
  				              rv = "ascii";
  				              break;
  				          case binary_prot:
  				              rv = "binary";
  				              break;
  				          case negotiating_prot:
  				              rv = "auto-negotiate";
  				              break;
  				      }
  				      return rv;
  				  }
  	          </pre>
  	        </div>
  	      </div>
  	    </div>
  	    <div class="panel panel-default">
  	      <div class="panel-heading">
  	        <h4 class="panel-title">
  	          <a data-toggle="collapse" data-parent="#accordion" href="#conn_new">
  				  conn *conn_new(const int sfd, enum conn_states init_state,
  				                  const int event_flags,
  				                  const int read_buffer_size, enum network_transport transport,
  				                  struct event_base *base)
  	          </a>
  	        </h4>
  	      </div>
  	      <div id="conn_new" class="panel-collapse collapse">
  	        <div class="panel-body">
  	          <pre>
  				  conn *conn_new(const int sfd, enum conn_states init_state,
  				                  const int event_flags,
  				                  const int read_buffer_size, enum network_transport transport,
  				                  struct event_base *base) {
  				      conn *c = conn_from_freelist();

  				      if (NULL == c) {
  				          if (!(c = (conn *)calloc(1, sizeof(conn)))) {
  				              fprintf(stderr, "calloc()\n");
  				              return NULL;
  				          }
  				          MEMCACHED_CONN_CREATE(c);

  				          c->rbuf = c->wbuf = 0;
  				          c->ilist = 0;
  				          c->suffixlist = 0;
  				          c->iov = 0;
  				          c->msglist = 0;
  				          c->hdrbuf = 0;

  				          c->rsize = read_buffer_size;
  				          c->wsize = DATA_BUFFER_SIZE;
  				          c->isize = ITEM_LIST_INITIAL;
  				          c->suffixsize = SUFFIX_LIST_INITIAL;
  				          c->iovsize = IOV_LIST_INITIAL;
  				          c->msgsize = MSG_LIST_INITIAL;
  				          c->hdrsize = 0;

  				          c->rbuf = (char *)malloc((size_t)c->rsize);
  				          c->wbuf = (char *)malloc((size_t)c->wsize);
  				          c->ilist = (item **)malloc(sizeof(item *) * c->isize);
  				          c->suffixlist = (char **)malloc(sizeof(char *) * c->suffixsize);
  				          c->iov = (struct iovec *)malloc(sizeof(struct iovec) * c->iovsize);
  				          c->msglist = (struct msghdr *)malloc(sizeof(struct msghdr) * c->msgsize);

  				          if (c->rbuf == 0 || c->wbuf == 0 || c->ilist == 0 || c->iov == 0 ||
  				                  c->msglist == 0 || c->suffixlist == 0) {
  				              conn_free(c);
  				              fprintf(stderr, "malloc()\n");
  				              return NULL;
  				          }

  				          STATS_LOCK();
  				          stats.conn_structs++;
  				          STATS_UNLOCK();
  				      }

  				      c->transport = transport;
  				      c->protocol = settings.binding_protocol;

  				      /* unix socket mode doesn't need this, so zeroed out.  but why
  				       * is this done for every command?  presumably for UDP
  				       * mode.  */
  				      if (!settings.socketpath) {
  				          c->request_addr_size = sizeof(c->request_addr);
  				      } else {
  				          c->request_addr_size = 0;
  				      }

  				      if (settings.verbose > 1) {
  				          if (init_state == conn_listening) {
  				              fprintf(stderr, "<%d server listening (%s)\n", sfd,
  				                  prot_text(c->protocol));
  				          } else if (IS_UDP(transport)) {
  				              fprintf(stderr, "<%d server listening (udp)\n", sfd);
  				          } else if (c->protocol == negotiating_prot) {
  				              fprintf(stderr, "<%d new auto-negotiating client connection\n",
  				                      sfd);
  				          } else if (c->protocol == ascii_prot) {
  				              fprintf(stderr, "<%d new ascii client connection.\n", sfd);
  				          } else if (c->protocol == binary_prot) {
  				              fprintf(stderr, "<%d new binary client connection.\n", sfd);
  				          } else {
  				              fprintf(stderr, "<%d new unknown (%d) client connection\n",
  				                  sfd, c->protocol);
  				              assert(false);
  				          }
  				      }

  				      c->sfd = sfd;
  				      c->state = init_state;
  				      c->rlbytes = 0;
  				      c->cmd = -1;
  				      c->rbytes = c->wbytes = 0;
  				      c->wcurr = c->wbuf;
  				      c->rcurr = c->rbuf;
  				      c->ritem = 0;
  				      c->icurr = c->ilist;
  				      c->suffixcurr = c->suffixlist;
  				      c->ileft = 0;
  				      c->suffixleft = 0;
  				      c->iovused = 0;
  				      c->msgcurr = 0;
  				      c->msgused = 0;

  				      c->write_and_go = init_state;
  				      c->write_and_free = 0;
  				      c->item = 0;

  				      c->noreply = false;

  				      event_set(&c->event, sfd, event_flags, event_handler, (void *)c);
  				      event_base_set(base, &c->event);
  				      c->ev_flags = event_flags;

  				      if (event_add(&c->event, 0) == -1) {
  				          if (conn_add_to_freelist(c)) {
  				              conn_free(c);
  				          }
  				          perror("event_add");
  				          return NULL;
  				      }

  				      STATS_LOCK();
  				      stats.curr_conns++;
  				      stats.total_conns++;
  				      STATS_UNLOCK();

  				      MEMCACHED_CONN_ALLOCATE(c->sfd);

  				      return c;
  				  }
          	
  	          </pre>
  	        </div>
  	      </div>
  	    </div>
  	    <div class="panel panel-default">
  	      <div class="panel-heading">
  	        <h4 class="panel-title">
  	          <a data-toggle="collapse" data-parent="#accordion" href="#conn_cleanup">
  	            static void conn_cleanup(conn *c)
  	          </a>
  	        </h4>
  	      </div>
  	      <div id="conn_cleanup" class="panel-collapse collapse">
  	        <div class="panel-body">
  	          <pre>
  				  static void conn_cleanup(conn *c) {
  				      assert(c != NULL);

  				      if (c->item) {
  				          item_remove(c->item);
  				          c->item = 0;
  				      }

  				      if (c->ileft != 0) {
  				          for (; c->ileft > 0; c->ileft--,c->icurr++) {
  				              item_remove(*(c->icurr));
  				          }
  				      }

  				      if (c->suffixleft != 0) {
  				          for (; c->suffixleft > 0; c->suffixleft--, c->suffixcurr++) {
  				              cache_free(c->thread->suffix_cache, *(c->suffixcurr));
  				          }
  				      }

  				      if (c->write_and_free) {
  				          free(c->write_and_free);
  				          c->write_and_free = 0;
  				      }

  				      if (c->sasl_conn) {
  				          assert(settings.sasl);
  				          sasl_dispose(&c->sasl_conn);
  				          c->sasl_conn = NULL;
  				      }

  				      if (IS_UDP(c->transport)) {
  				          conn_set_state(c, conn_read);
  				      }
  				  }
          	
  	          </pre>
  	        </div>
  	      </div>
  	    </div>
  	    <div class="panel panel-default">
  	      <div class="panel-heading">
  	        <h4 class="panel-title">
  	          <a data-toggle="collapse" data-parent="#accordion" href="#conn_shrink">
  	            static void conn_shrink(conn *c)
  	          </a>
  	        </h4>
  	      </div>
  	      <div id="conn_shrink" class="panel-collapse collapse">
  	        <div class="panel-body">
  	          <pre>
  				  /*
  				   * Shrinks a connection's buffers if they're too big.  This prevents
  				   * periodic large "get" requests from permanently chewing lots of server
  				   * memory.
  				   *
  				   * This should only be called in between requests since it can wipe output
  				   * buffers!
  				   */
  				  static void conn_shrink(conn *c) {
  				      assert(c != NULL);

  				      if (IS_UDP(c->transport))
  				          return;

  				      if (c->rsize > READ_BUFFER_HIGHWAT && c->rbytes < DATA_BUFFER_SIZE) {
  				          char *newbuf;

  				          if (c->rcurr != c->rbuf)
  				              memmove(c->rbuf, c->rcurr, (size_t)c->rbytes);

  				          newbuf = (char *)realloc((void *)c->rbuf, DATA_BUFFER_SIZE);

  				          if (newbuf) {
  				              c->rbuf = newbuf;
  				              c->rsize = DATA_BUFFER_SIZE;
  				          }
  				          /* TODO check other branch... */
  				          c->rcurr = c->rbuf;
  				      }

  				      if (c->isize > ITEM_LIST_HIGHWAT) {
  				          item **newbuf = (item**) realloc((void *)c->ilist, ITEM_LIST_INITIAL * sizeof(c->ilist[0]));
  				          if (newbuf) {
  				              c->ilist = newbuf;
  				              c->isize = ITEM_LIST_INITIAL;
  				          }
  				      /* TODO check error condition? */
  				      }

  				      if (c->msgsize > MSG_LIST_HIGHWAT) {
  				          struct msghdr *newbuf = (struct msghdr *) realloc((void *)c->msglist, MSG_LIST_INITIAL * sizeof(c->msglist[0]));
  				          if (newbuf) {
  				              c->msglist = newbuf;
  				              c->msgsize = MSG_LIST_INITIAL;
  				          }
  				      /* TODO check error condition? */
  				      }

  				      if (c->iovsize > IOV_LIST_HIGHWAT) {
  				          struct iovec *newbuf = (struct iovec *) realloc((void *)c->iov, IOV_LIST_INITIAL * sizeof(c->iov[0]));
  				          if (newbuf) {
  				              c->iov = newbuf;
  				              c->iovsize = IOV_LIST_INITIAL;
  				          }
  				      /* TODO check return value */
  				      }
  				  }
          	
  	          </pre>
  	        </div>
  	      </div>
  	    </div>
  	    <div class="panel panel-default">
  	      <div class="panel-heading">
  	        <h4 class="panel-title">
  	          <a data-toggle="collapse" data-parent="#accordion" href="#state_text">
  	            static const char *state_text(enum conn_states state)
  	          </a>
  	        </h4>
  	      </div>
  	      <div id="state_text" class="panel-collapse collapse">
  	        <div class="panel-body">
  	          <pre>
  				  /**
  				   * Convert a state name to a human readable form.
  				   */
  				  static const char *state_text(enum conn_states state) {
  				      const char* const statenames[] = { "conn_listening",
  				                                         "conn_new_cmd",
  				                                         "conn_waiting",
  				                                         "conn_read",
  				                                         "conn_parse_cmd",
  				                                         "conn_write",
  				                                         "conn_nread",
  				                                         "conn_swallow",
  				                                         "conn_closing",
  				                                         "conn_mwrite" };
  				      return statenames[state];
  				  }
          	
  	          </pre>
  	        </div>
  	      </div>
  	    </div>
  	    <div class="panel panel-default">
  	      <div class="panel-heading">
  	        <h4 class="panel-title">
  	          <a data-toggle="collapse" data-parent="#accordion" href="#build_udp_headers">
  	            static int build_udp_headers(conn *c)
  	          </a>
  	        </h4>
  	      </div>
  	      <div id="build_udp_headers" class="panel-collapse collapse">
  	        <div class="panel-body">
  	          <pre>
  				  /*
  				   * Constructs a set of UDP headers and attaches them to the outgoing messages.
  				   */
  				  static int build_udp_headers(conn *c) {
  				      int i;
  				      unsigned char *hdr;

  				      assert(c != NULL);

  				      if (c->msgused > c->hdrsize) {
  				          void *new_hdrbuf;
  				          if (c->hdrbuf)
  				              new_hdrbuf = realloc(c->hdrbuf, c->msgused * 2 * UDP_HEADER_SIZE);
  				          else
  				              new_hdrbuf = malloc(c->msgused * 2 * UDP_HEADER_SIZE);
  				          if (! new_hdrbuf)
  				              return -1;
  				          c->hdrbuf = (unsigned char *)new_hdrbuf;
  				          c->hdrsize = c->msgused * 2;
  				      }

  				      hdr = c->hdrbuf;
  				      for (i = 0; i < c->msgused; i++) {
  				          c->msglist[i].msg_iov[0].iov_base = (void*)hdr;
  				          c->msglist[i].msg_iov[0].iov_len = UDP_HEADER_SIZE;
  				          *hdr++ = c->request_id / 256;
  				          *hdr++ = c->request_id % 256;
  				          *hdr++ = i / 256;
  				          *hdr++ = i % 256;
  				          *hdr++ = c->msgused / 256;
  				          *hdr++ = c->msgused % 256;
  				          *hdr++ = 0;
  				          *hdr++ = 0;
  				          assert((void *) hdr == (caddr_t)c->msglist[i].msg_iov[0].iov_base + UDP_HEADER_SIZE);
  				      }

  				      return 0;
  				  }
          	
  	          </pre>
  	        </div>
  	      </div>
  	    </div>
  	    <div class="panel panel-default">
  	      <div class="panel-heading">
  	        <h4 class="panel-title">
  	          <a data-toggle="collapse" data-parent="#accordion" href="#out_string">
  	            static void out_string(conn *c, const char *str) 
  	          </a>
  	        </h4>
  	      </div>
  	      <div id="out_string" class="panel-collapse collapse">
  	        <div class="panel-body">
  	          <pre>
  				  static void out_string(conn *c, const char *str) {
  				      size_t len;

  				      assert(c != NULL);

  				      if (c->noreply) {
  				          if (settings.verbose > 1)
  				              fprintf(stderr, ">%d NOREPLY %s\n", c->sfd, str);
  				          c->noreply = false;
  				          conn_set_state(c, conn_new_cmd);
  				          return;
  				      }

  				      if (settings.verbose > 1)
  				          fprintf(stderr, ">%d %s\n", c->sfd, str);

  				      /* Nuke a partial output... */
  				      c->msgcurr = 0;
  				      c->msgused = 0;
  				      c->iovused = 0;
  				      add_msghdr(c);

  				      len = strlen(str);
  				      if ((len + 2) > c->wsize) {
  				          /* ought to be always enough. just fail for simplicity */
  				          str = "SERVER_ERROR output line too long";
  				          len = strlen(str);
  				      }

  				      memcpy(c->wbuf, str, len);
  				      memcpy(c->wbuf + len, "\r\n", 2);
  				      c->wbytes = len + 2;
  				      c->wcurr = c->wbuf;

  				      conn_set_state(c, conn_write);
  				      c->write_and_go = conn_new_cmd;
  				      return;
  				  }
          	
  	          </pre>
  	        </div>
  	      </div>
  	    </div>
  	    <div class="panel panel-default">
  	      <div class="panel-heading">
  	        <h4 class="panel-title">
  	          <a data-toggle="collapse" data-parent="#accordion" href="#complete_nread_ascii">
  	            static void complete_nread_ascii(conn *c) 
  	          </a>
  	        </h4>
  	      </div>
  	      <div id="complete_nread_ascii" class="panel-collapse collapse">
  	        <div class="panel-body">
  	          <pre>
  				  /*
  				   * we get here after reading the value in set/add/replace commands. The command
  				   * has been stored in c->cmd, and the item is ready in c->item.
  				   */
  				  static void complete_nread_ascii(conn *c) {
  				      assert(c != NULL);

  				      item *it = c->item;
  				      int comm = c->cmd;
  				      enum store_item_type ret;

  				      pthread_mutex_lock(&c->thread->stats.mutex);
  				      c->thread->stats.slab_stats[it->slabs_clsid].set_cmds++;
  				      pthread_mutex_unlock(&c->thread->stats.mutex);

  				      if (strncmp(ITEM_data(it) + it->nbytes - 2, "\r\n", 2) != 0) {
  				          out_string(c, "CLIENT_ERROR bad data chunk");
  				      } else {
  				        ret = store_item(it, comm, c);

  				  #ifdef ENABLE_DTRACE
  				        uint64_t cas = ITEM_get_cas(it);
  				        switch (c->cmd) {
  				        case NREAD_ADD:
  				            MEMCACHED_COMMAND_ADD(c->sfd, ITEM_key(it), it->nkey,
  				                                  (ret == 1) ? it->nbytes : -1, cas);
  				            break;
  				        case NREAD_REPLACE:
  				            MEMCACHED_COMMAND_REPLACE(c->sfd, ITEM_key(it), it->nkey,
  				                                      (ret == 1) ? it->nbytes : -1, cas);
  				            break;
  				        case NREAD_APPEND:
  				            MEMCACHED_COMMAND_APPEND(c->sfd, ITEM_key(it), it->nkey,
  				                                     (ret == 1) ? it->nbytes : -1, cas);
  				            break;
  				        case NREAD_PREPEND:
  				            MEMCACHED_COMMAND_PREPEND(c->sfd, ITEM_key(it), it->nkey,
  				                                      (ret == 1) ? it->nbytes : -1, cas);
  				            break;
  				        case NREAD_SET:
  				            MEMCACHED_COMMAND_SET(c->sfd, ITEM_key(it), it->nkey,
  				                                  (ret == 1) ? it->nbytes : -1, cas);
  				            break;
  				        case NREAD_CAS:
  				            MEMCACHED_COMMAND_CAS(c->sfd, ITEM_key(it), it->nkey, it->nbytes,
  				                                  cas);
  				            break;
  				        }
  				  #endif

  				        switch (ret) {
  				        case STORED:
  				            out_string(c, "STORED");
  				            break;
  				        case EXISTS:
  				            out_string(c, "EXISTS");
  				            break;
  				        case NOT_FOUND:
  				            out_string(c, "NOT_FOUND");
  				            break;
  				        case NOT_STORED:
  				            out_string(c, "NOT_STORED");
  				            break;
  				        default:
  				            out_string(c, "SERVER_ERROR Unhandled storage type.");
  				        }

  				      }

  				      item_remove(c->item);       /* release the c->item reference */
  				      c->item = 0;
  				  }
          	
  	          </pre>
  	        </div>
  	      </div>
  	    </div>
  	    <div class="panel panel-default">
  	      <div class="panel-heading">
  	        <h4 class="panel-title">
  	          <a data-toggle="collapse" data-parent="#accordion" href="#binary_get_request">
  	            static void* binary_get_request(conn *c)
  	          </a>
  	        </h4>
  	      </div>
  	      <div id="binary_get_request" class="panel-collapse collapse">
  	        <div class="panel-body">
  	          <pre>
  				  /**
  				   * get a pointer to the start of the request struct for the current command
  				   */
  				  static void* binary_get_request(conn *c) {
  				      char *ret = c->rcurr;
  				      ret -= (sizeof(c->binary_header) + c->binary_header.request.keylen +
  				              c->binary_header.request.extlen);

  				      assert(ret >= c->rbuf);
  				      return ret;
  				  }
          	
  	          </pre>
  	        </div>
  	      </div>
  	    </div>
  	    <div class="panel panel-default">
  	      <div class="panel-heading">
  	        <h4 class="panel-title">
  	          <a data-toggle="collapse" data-parent="#accordion" href="#binary_get_key">
  	            static char* binary_get_key(conn *c)
  	          </a>
  	        </h4>
  	      </div>
  	      <div id="binary_get_key" class="panel-collapse collapse">
  	        <div class="panel-body">
  	          <pre>
  				  /**
  				   * get a pointer to the key in this request
  				   */
  				  static char* binary_get_key(conn *c) {
  				      return c->rcurr - (c->binary_header.request.keylen);
  				  }
          	
  	          </pre>
  	        </div>
  	      </div>
  	    </div>
  	    <div class="panel panel-default">
  	      <div class="panel-heading">
  	        <h4 class="panel-title">
  	          <a data-toggle="collapse" data-parent="#accordion" href="#add_bin_header">
  	            static void add_bin_header(conn *c, uint16_t err, uint8_t hdr_len, uint16_t key_len, uint32_t body_len)
  	          </a>
  	        </h4>
  	      </div>
  	      <div id="add_bin_header" class="panel-collapse collapse">
  	        <div class="panel-body">
  	          <pre>
  				  static void add_bin_header(conn *c, uint16_t err, uint8_t hdr_len, uint16_t key_len, uint32_t body_len) {
  				      protocol_binary_response_header* header;

  				      assert(c);

  				      c->msgcurr = 0;
  				      c->msgused = 0;
  				      c->iovused = 0;
  				      if (add_msghdr(c) != 0) {
  				          /* XXX:  out_string is inappropriate here */
  				          out_string(c, "SERVER_ERROR out of memory");
  				          return;
  				      }

  				      header = (protocol_binary_response_header *)c->wbuf;

  				      header->response.magic = (uint8_t)PROTOCOL_BINARY_RES;
  				      header->response.opcode = c->binary_header.request.opcode;
  				      header->response.keylen = (uint16_t)htons(key_len);

  				      header->response.extlen = (uint8_t)hdr_len;
  				      header->response.datatype = (uint8_t)PROTOCOL_BINARY_RAW_BYTES;
  				      header->response.status = (uint16_t)htons(err);

  				      header->response.bodylen = htonl(body_len);
  				      header->response.opaque = c->opaque;
  				      header->response.cas = htonll(c->cas);

  				      if (settings.verbose > 1) {
  				          int ii;
  				          fprintf(stderr, ">%d Writing bin response:", c->sfd);
  				          for (ii = 0; ii < sizeof(header->bytes); ++ii) {
  				              if (ii % 4 == 0) {
  				                  fprintf(stderr, "\n>%d  ", c->sfd);
  				              }
  				              fprintf(stderr, " 0x%02x", header->bytes[ii]);
  				          }
  				          fprintf(stderr, "\n");
  				      }

  				      add_iov(c, c->wbuf, sizeof(header->response));
  				  }
          	
  	          </pre>
  	        </div>
  	      </div>
  	    </div>
  	    <div class="panel panel-default">
  	      <div class="panel-heading">
  	        <h4 class="panel-title">
  	          <a data-toggle="collapse" data-parent="#accordion" href="#write_bin_error">
  	            static void write_bin_error(conn *c, protocol_binary_response_status err, int swallow)
  	          </a>
  	        </h4>
  	      </div>
  	      <div id="write_bin_error" class="panel-collapse collapse">
  	        <div class="panel-body">
  	          <pre>
  				  static void write_bin_error(conn *c, protocol_binary_response_status err, int swallow) {
  				      const char *errstr = "Unknown error";
  				      size_t len;

  				      switch (err) {
  				      case PROTOCOL_BINARY_RESPONSE_ENOMEM:
  				          errstr = "Out of memory";
  				          break;
  				      case PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND:
  				          errstr = "Unknown command";
  				          break;
  				      case PROTOCOL_BINARY_RESPONSE_KEY_ENOENT:
  				          errstr = "Not found";
  				          break;
  				      case PROTOCOL_BINARY_RESPONSE_EINVAL:
  				          errstr = "Invalid arguments";
  				          break;
  				      case PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS:
  				          errstr = "Data exists for key.";
  				          break;
  				      case PROTOCOL_BINARY_RESPONSE_E2BIG:
  				          errstr = "Too large.";
  				          break;
  				      case PROTOCOL_BINARY_RESPONSE_DELTA_BADVAL:
  				          errstr = "Non-numeric server-side value for incr or decr";
  				          break;
  				      case PROTOCOL_BINARY_RESPONSE_NOT_STORED:
  				          errstr = "Not stored.";
  				          break;
  				      case PROTOCOL_BINARY_RESPONSE_AUTH_ERROR:
  				          errstr = "Auth failure.";
  				          break;
  				      default:
  				          assert(false);
  				          errstr = "UNHANDLED ERROR";
  				          fprintf(stderr, ">%d UNHANDLED ERROR: %d\n", c->sfd, err);
  				      }

  				      if (settings.verbose > 1) {
  				          fprintf(stderr, ">%d Writing an error: %s\n", c->sfd, errstr);
  				      }

  				      len = strlen(errstr);
  				      add_bin_header(c, err, 0, 0, len);
  				      if (len > 0) {
  				          add_iov(c, errstr, len);
  				      }
  				      conn_set_state(c, conn_mwrite);
  				      if(swallow > 0) {
  				          c->sbytes = swallow;
  				          c->write_and_go = conn_swallow;
  				      } else {
  				          c->write_and_go = conn_new_cmd;
  				      }
  				  }
          	
  	          </pre>
  	        </div>
  	      </div>
  	    </div>
  	    <div class="panel panel-default">
  	      <div class="panel-heading">
  	        <h4 class="panel-title">
  	          <a data-toggle="collapse" data-parent="#accordion" href="#write_bin_response">
  	            static void write_bin_response(conn *c, void *d, int hlen, int keylen, int dlen)
  	          </a>
  	        </h4>
  	      </div>
  	      <div id="write_bin_response" class="panel-collapse collapse">
  	        <div class="panel-body">
  	          <pre>
  				  /* Form and send a response to a command over the binary protocol */
  				  static void write_bin_response(conn *c, void *d, int hlen, int keylen, int dlen) {
  				      if (!c->noreply || c->cmd == PROTOCOL_BINARY_CMD_GET ||
  				          c->cmd == PROTOCOL_BINARY_CMD_GETK) {
  				          add_bin_header(c, 0, hlen, keylen, dlen);
  				          if(dlen > 0) {
  				              add_iov(c, d, dlen);
  				          }
  				          conn_set_state(c, conn_mwrite);
  				          c->write_and_go = conn_new_cmd;
  				      } else {
  				          conn_set_state(c, conn_new_cmd);
  				      }
  				  }
          	
  	          </pre>
  	        </div>
  	      </div>
  	    </div>
  	    <div class="panel panel-default">
  	      <div class="panel-heading">
  	        <h4 class="panel-title">
  	          <a data-toggle="collapse" data-parent="#accordion" href="#complete_incr_bin">
  	            static void complete_incr_bin(conn *c)
  	          </a>
  	        </h4>
  	      </div>
  	      <div id="complete_incr_bin" class="panel-collapse collapse">
  	        <div class="panel-body">
  	          <pre>
  				  static void complete_incr_bin(conn *c) {
  				      item *it;
  				      char *key;
  				      size_t nkey;
  				      /* Weird magic in add_delta forces me to pad here */
  				      char tmpbuf[INCR_MAX_STORAGE_LEN];
  				      uint64_t cas = 0;

  				      protocol_binary_response_incr* rsp = (protocol_binary_response_incr*)c->wbuf;
  				      protocol_binary_request_incr* req = binary_get_request(c);

  				      assert(c != NULL);
  				      assert(c->wsize >= sizeof(*rsp));

  				      /* fix byteorder in the request */
  				      req->message.body.delta = ntohll(req->message.body.delta);
  				      req->message.body.initial = ntohll(req->message.body.initial);
  				      req->message.body.expiration = ntohl(req->message.body.expiration);
  				      key = binary_get_key(c);
  				      nkey = c->binary_header.request.keylen;

  				      if (settings.verbose > 1) {
  				          int i;
  				          fprintf(stderr, "incr ");

  				          for (i = 0; i < nkey; i++) {
  				              fprintf(stderr, "%c", key[i]);
  				          }
  				          fprintf(stderr, " %lld, %llu, %d\n",
  				                  (long long)req->message.body.delta,
  				                  (long long)req->message.body.initial,
  				                  req->message.body.expiration);
  				      }

  				      if (c->binary_header.request.cas != 0) {
  				          cas = c->binary_header.request.cas;
  				      }
  				      switch(add_delta(c, key, nkey, c->cmd == PROTOCOL_BINARY_CMD_INCREMENT,
  				                       req->message.body.delta, tmpbuf,
  				                       &cas)) {
  				      case OK:
  				          rsp->message.body.value = htonll(strtoull(tmpbuf, NULL, 10));
  				          if (cas) {
  				              c->cas = cas;
  				          }
  				          write_bin_response(c, &rsp->message.body, 0, 0,
  				                             sizeof(rsp->message.body.value));
  				          break;
  				      case NON_NUMERIC:
  				          write_bin_error(c, PROTOCOL_BINARY_RESPONSE_DELTA_BADVAL, 0);
  				          break;
  				      case EOM:
  				          write_bin_error(c, PROTOCOL_BINARY_RESPONSE_ENOMEM, 0);
  				          break;
  				      case DELTA_ITEM_NOT_FOUND:
  				          if (req->message.body.expiration != 0xffffffff) {
  				              /* Save some room for the response */
  				              rsp->message.body.value = htonll(req->message.body.initial);
  				              it = item_alloc(key, nkey, 0, realtime(req->message.body.expiration),
  				                              INCR_MAX_STORAGE_LEN);

  				              if (it != NULL) {
  				                  snprintf(ITEM_data(it), INCR_MAX_STORAGE_LEN, "%llu",
  				                           (unsigned long long)req->message.body.initial);

  				                  if (store_item(it, NREAD_ADD, c)) {
  				                      c->cas = ITEM_get_cas(it);
  				                      write_bin_response(c, &rsp->message.body, 0, 0, sizeof(rsp->message.body.value));
  				                  } else {
  				                      write_bin_error(c, PROTOCOL_BINARY_RESPONSE_NOT_STORED, 0);
  				                  }
  				                  item_remove(it);         /* release our reference */
  				              } else {
  				                  write_bin_error(c, PROTOCOL_BINARY_RESPONSE_ENOMEM, 0);
  				              }
  				          } else {
  				              pthread_mutex_lock(&c->thread->stats.mutex);
  				              if (c->cmd == PROTOCOL_BINARY_CMD_INCREMENT) {
  				                  c->thread->stats.incr_misses++;
  				              } else {
  				                  c->thread->stats.decr_misses++;
  				              }
  				              pthread_mutex_unlock(&c->thread->stats.mutex);

  				              write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, 0);
  				          }
  				          break;
  				      case DELTA_ITEM_CAS_MISMATCH:
  				          write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS, 0);
  				          break;
  				      }
  				  }
          	
  	          </pre>
  	        </div>
  	      </div>
  	    </div>
  	    <div class="panel panel-default">
  	      <div class="panel-heading">
  	        <h4 class="panel-title">
  	          <a data-toggle="collapse" data-parent="#accordion" href="#complete_update_bin">
  	            static void complete_update_bin(conn *c)
  	          </a>
  	        </h4>
  	      </div>
  	      <div id="complete_update_bin" class="panel-collapse collapse">
  	        <div class="panel-body">
  	          <pre>
  				  static void complete_update_bin(conn *c) {
  				      protocol_binary_response_status eno = PROTOCOL_BINARY_RESPONSE_EINVAL;
  				      enum store_item_type ret = NOT_STORED;
  				      assert(c != NULL);

  				      item *it = c->item;

  				      pthread_mutex_lock(&c->thread->stats.mutex);
  				      c->thread->stats.slab_stats[it->slabs_clsid].set_cmds++;
  				      pthread_mutex_unlock(&c->thread->stats.mutex);

  				      /* We don't actually receive the trailing two characters in the bin
  				       * protocol, so we're going to just set them here */
  				      *(ITEM_data(it) + it->nbytes - 2) = '\r';
  				      *(ITEM_data(it) + it->nbytes - 1) = '\n';

  				      ret = store_item(it, c->cmd, c);

  				  #ifdef ENABLE_DTRACE
  				      uint64_t cas = ITEM_get_cas(it);
  				      switch (c->cmd) {
  				      case NREAD_ADD:
  				          MEMCACHED_COMMAND_ADD(c->sfd, ITEM_key(it), it->nkey,
  				                                (ret == STORED) ? it->nbytes : -1, cas);
  				          break;
  				      case NREAD_REPLACE:
  				          MEMCACHED_COMMAND_REPLACE(c->sfd, ITEM_key(it), it->nkey,
  				                                    (ret == STORED) ? it->nbytes : -1, cas);
  				          break;
  				      case NREAD_APPEND:
  				          MEMCACHED_COMMAND_APPEND(c->sfd, ITEM_key(it), it->nkey,
  				                                   (ret == STORED) ? it->nbytes : -1, cas);
  				          break;
  				      case NREAD_PREPEND:
  				          MEMCACHED_COMMAND_PREPEND(c->sfd, ITEM_key(it), it->nkey,
  				                                   (ret == STORED) ? it->nbytes : -1, cas);
  				          break;
  				      case NREAD_SET:
  				          MEMCACHED_COMMAND_SET(c->sfd, ITEM_key(it), it->nkey,
  				                                (ret == STORED) ? it->nbytes : -1, cas);
  				          break;
  				      }
  				  #endif

  				      switch (ret) {
  				      case STORED:
  				          /* Stored */
  				          write_bin_response(c, NULL, 0, 0, 0);
  				          break;
  				      case EXISTS:
  				          write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS, 0);
  				          break;
  				      case NOT_FOUND:
  				          write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, 0);
  				          break;
  				      case NOT_STORED:
  				          if (c->cmd == NREAD_ADD) {
  				              eno = PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS;
  				          } else if(c->cmd == NREAD_REPLACE) {
  				              eno = PROTOCOL_BINARY_RESPONSE_KEY_ENOENT;
  				          } else {
  				              eno = PROTOCOL_BINARY_RESPONSE_NOT_STORED;
  				          }
  				          write_bin_error(c, eno, 0);
  				      }

  				      item_remove(c->item);       /* release the c->item reference */
  				      c->item = 0;
  				  }
          	
  	          </pre>
  	        </div>
  	      </div>
  	    </div>
  	    <div class="panel panel-default">
  	      <div class="panel-heading">
  	        <h4 class="panel-title">
  	          <a data-toggle="collapse" data-parent="#accordion" href="#process_bin_touch">
  	            static void process_bin_touch(conn *c)
  	          </a>
  	        </h4>
  	      </div>
  	      <div id="process_bin_touch" class="panel-collapse collapse">
  	        <div class="panel-body">
  	          <pre>
  				  static void process_bin_touch(conn *c) {
  				      item *it;

  				      protocol_binary_response_get* rsp = (protocol_binary_response_get*)c->wbuf;
  				      char* key = binary_get_key(c);
  				      size_t nkey = c->binary_header.request.keylen;
  				      protocol_binary_request_touch *t = binary_get_request(c);
  				      time_t exptime = ntohl(t->message.body.expiration);

  				      if (settings.verbose > 1) {
  				          int ii;
  				          /* May be GAT/GATQ/etc */
  				          fprintf(stderr, "<%d TOUCH ", c->sfd);
  				          for (ii = 0; ii < nkey; ++ii) {
  				              fprintf(stderr, "%c", key[ii]);
  				          }
  				          fprintf(stderr, "\n");
  				      }

  				      it = item_touch(key, nkey, realtime(exptime));

  				      if (it) {
  				          /* the length has two unnecessary bytes ("\r\n") */
  				          uint16_t keylen = 0;
  				          uint32_t bodylen = sizeof(rsp->message.body) + (it->nbytes - 2);

  				          item_update(it);
  				          pthread_mutex_lock(&c->thread->stats.mutex);
  				          c->thread->stats.touch_cmds++;
  				          c->thread->stats.slab_stats[it->slabs_clsid].touch_hits++;
  				          pthread_mutex_unlock(&c->thread->stats.mutex);

  				          MEMCACHED_COMMAND_TOUCH(c->sfd, ITEM_key(it), it->nkey,
  				                                  it->nbytes, ITEM_get_cas(it));

  				          if (c->cmd == PROTOCOL_BINARY_CMD_TOUCH) {
  				              bodylen -= it->nbytes - 2;
  				          } else if (c->cmd == PROTOCOL_BINARY_CMD_GATK) {
  				              bodylen += nkey;
  				              keylen = nkey;
  				          }

  				          add_bin_header(c, 0, sizeof(rsp->message.body), keylen, bodylen);
  				          rsp->message.header.response.cas = htonll(ITEM_get_cas(it));

  				          // add the flags
  				          rsp->message.body.flags = htonl(strtoul(ITEM_suffix(it), NULL, 10));
  				          add_iov(c, &rsp->message.body, sizeof(rsp->message.body));

  				          if (c->cmd == PROTOCOL_BINARY_CMD_GATK) {
  				              add_iov(c, ITEM_key(it), nkey);
  				          }

  				          /* Add the data minus the CRLF */
  				          if (c->cmd != PROTOCOL_BINARY_CMD_TOUCH) {
  				              add_iov(c, ITEM_data(it), it->nbytes - 2);
  				          }

  				          conn_set_state(c, conn_mwrite);
  				          c->write_and_go = conn_new_cmd;
  				          /* Remember this command so we can garbage collect it later */
  				          c->item = it;
  				      } else {
  				          pthread_mutex_lock(&c->thread->stats.mutex);
  				          c->thread->stats.touch_cmds++;
  				          c->thread->stats.touch_misses++;
  				          pthread_mutex_unlock(&c->thread->stats.mutex);

  				          MEMCACHED_COMMAND_TOUCH(c->sfd, key, nkey, -1, 0);

  				          if (c->noreply) {
  				              conn_set_state(c, conn_new_cmd);
  				          } else {
  				              if (c->cmd == PROTOCOL_BINARY_CMD_GATK) {
  				                  char *ofs = c->wbuf + sizeof(protocol_binary_response_header);
  				                  add_bin_header(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT,
  				                          0, nkey, nkey);
  				                  memcpy(ofs, key, nkey);
  				                  add_iov(c, ofs, nkey);
  				                  conn_set_state(c, conn_mwrite);
  				                  c->write_and_go = conn_new_cmd;
  				              } else {
  				                  write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, 0);
  				              }
  				          }
  				      }

  				      if (settings.detail_enabled) {
  				          stats_prefix_record_get(key, nkey, NULL != it);
  				      }
  				  }
          	
  	          </pre>
  	        </div>
  	      </div>
  	    </div>
  	    <div class="panel panel-default">
  	      <div class="panel-heading">
  	        <h4 class="panel-title">
  	          <a data-toggle="collapse" data-parent="#accordion" href="#process_bin_get">
  	            static void process_bin_get(conn *c)
  	          </a>
  	        </h4>
  	      </div>
  	      <div id="process_bin_get" class="panel-collapse collapse">
  	        <div class="panel-body">
  	          <pre>
  				  static void process_bin_get(conn *c) {
  				      item *it;

  				      protocol_binary_response_get* rsp = (protocol_binary_response_get*)c->wbuf;
  				      char* key = binary_get_key(c);
  				      size_t nkey = c->binary_header.request.keylen;

  				      if (settings.verbose > 1) {
  				          int ii;
  				          fprintf(stderr, "<%d GET ", c->sfd);
  				          for (ii = 0; ii < nkey; ++ii) {
  				              fprintf(stderr, "%c", key[ii]);
  				          }
  				          fprintf(stderr, "\n");
  				      }

  				      it = item_get(key, nkey);
  				      if (it) {
  				          /* the length has two unnecessary bytes ("\r\n") */
  				          uint16_t keylen = 0;
  				          uint32_t bodylen = sizeof(rsp->message.body) + (it->nbytes - 2);

  				          item_update(it);
  				          pthread_mutex_lock(&c->thread->stats.mutex);
  				          c->thread->stats.get_cmds++;
  				          c->thread->stats.slab_stats[it->slabs_clsid].get_hits++;
  				          pthread_mutex_unlock(&c->thread->stats.mutex);

  				          MEMCACHED_COMMAND_GET(c->sfd, ITEM_key(it), it->nkey,
  				                                it->nbytes, ITEM_get_cas(it));

  				          if (c->cmd == PROTOCOL_BINARY_CMD_GETK) {
  				              bodylen += nkey;
  				              keylen = nkey;
  				          }
  				          add_bin_header(c, 0, sizeof(rsp->message.body), keylen, bodylen);
  				          rsp->message.header.response.cas = htonll(ITEM_get_cas(it));

  				          // add the flags
  				          rsp->message.body.flags = htonl(strtoul(ITEM_suffix(it), NULL, 10));
  				          add_iov(c, &rsp->message.body, sizeof(rsp->message.body));

  				          if (c->cmd == PROTOCOL_BINARY_CMD_GETK) {
  				              add_iov(c, ITEM_key(it), nkey);
  				          }

  				          /* Add the data minus the CRLF */
  				          add_iov(c, ITEM_data(it), it->nbytes - 2);
  				          conn_set_state(c, conn_mwrite);
  				          c->write_and_go = conn_new_cmd;
  				          /* Remember this command so we can garbage collect it later */
  				          c->item = it;
  				      } else {
  				          pthread_mutex_lock(&c->thread->stats.mutex);
  				          c->thread->stats.get_cmds++;
  				          c->thread->stats.get_misses++;
  				          pthread_mutex_unlock(&c->thread->stats.mutex);

  				          MEMCACHED_COMMAND_GET(c->sfd, key, nkey, -1, 0);

  				          if (c->noreply) {
  				              conn_set_state(c, conn_new_cmd);
  				          } else {
  				              if (c->cmd == PROTOCOL_BINARY_CMD_GETK) {
  				                  char *ofs = c->wbuf + sizeof(protocol_binary_response_header);
  				                  add_bin_header(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT,
  				                          0, nkey, nkey);
  				                  memcpy(ofs, key, nkey);
  				                  add_iov(c, ofs, nkey);
  				                  conn_set_state(c, conn_mwrite);
  				                  c->write_and_go = conn_new_cmd;
  				              } else {
  				                  write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, 0);
  				              }
  				          }
  				      }

  				      if (settings.detail_enabled) {
  				          stats_prefix_record_get(key, nkey, NULL != it);
  				      }
  				  }
          	
  	          </pre>
  	        </div>
  	      </div>
  	    </div>
  	    <div class="panel panel-default">
  	      <div class="panel-heading">
  	        <h4 class="panel-title">
  	          <a data-toggle="collapse" data-parent="#accordion" href="#append_bin_stats(">
  				  static void append_bin_stats(const char *key, const uint16_t klen,
  				                               const char *val, const uint32_t vlen,
  				                               conn *c)
  	          </a>
  	        </h4>
  	      </div>
  	      <div id="append_bin_stats(" class="panel-collapse collapse">
  	        <div class="panel-body">
  	          <pre>
  				  static void append_bin_stats(const char *key, const uint16_t klen,
  				                               const char *val, const uint32_t vlen,
  				                               conn *c) {
  				      char *buf = c->stats.buffer + c->stats.offset;
  				      uint32_t bodylen = klen + vlen;
  				      protocol_binary_response_header header = {
  				          .response.magic = (uint8_t)PROTOCOL_BINARY_RES,
  				          .response.opcode = PROTOCOL_BINARY_CMD_STAT,
  				          .response.keylen = (uint16_t)htons(klen),
  				          .response.datatype = (uint8_t)PROTOCOL_BINARY_RAW_BYTES,
  				          .response.bodylen = htonl(bodylen),
  				          .response.opaque = c->opaque
  				      };

  				      memcpy(buf, header.bytes, sizeof(header.response));
  				      buf += sizeof(header.response);

  				      if (klen > 0) {
  				          memcpy(buf, key, klen);
  				          buf += klen;

  				          if (vlen > 0) {
  				              memcpy(buf, val, vlen);
  				          }
  				      }

  				      c->stats.offset += sizeof(header.response) + bodylen;
  				  }
          	
  	          </pre>
  	        </div>
  	      </div>
  	    </div>
  	    <div class="panel panel-default">
  	      <div class="panel-heading">
  	        <h4 class="panel-title">
  	          <a data-toggle="collapse" data-parent="#accordion" href="#append_ascii_stats">
  				  static void append_ascii_stats(const char *key, const uint16_t klen,
  				                                 const char *val, const uint32_t vlen,
  				                                 conn *c) 
  	          </a>
  	        </h4>
  	      </div>
  	      <div id="append_ascii_stats" class="panel-collapse collapse">
  	        <div class="panel-body">
  	          <pre>
  				  static void append_ascii_stats(const char *key, const uint16_t klen,
  				                                 const char *val, const uint32_t vlen,
  				                                 conn *c) {
  				      char *pos = c->stats.buffer + c->stats.offset;
  				      uint32_t nbytes = 0;
  				      int remaining = c->stats.size - c->stats.offset;
  				      int room = remaining - 1;

  				      if (klen == 0 && vlen == 0) {
  				          nbytes = snprintf(pos, room, "END\r\n");
  				      } else if (vlen == 0) {
  				          nbytes = snprintf(pos, room, "STAT %s\r\n", key);
  				      } else {
  				          nbytes = snprintf(pos, room, "STAT %s %s\r\n", key, val);
  				      }

  				      c->stats.offset += nbytes;
  				  }
          	
  	          </pre>
  	        </div>
  	      </div>
  	    </div>
  	    <div class="panel panel-default">
  	      <div class="panel-heading">
  	        <h4 class="panel-title">
  	          <a data-toggle="collapse" data-parent="#accordion" href="#collapseTwo">
  	            static void maximize_sndbuf(const int sfd)
  	          </a>
  	        </h4>
  	      </div>
  	      <div id="collapseTwo" class="panel-collapse collapse">
  	        <div class="panel-body">
  	          <pre>
  				  /*
  				   * Sets a socket's send buffer size to the maximum allowed by the system.
  				   */
  				  static void maximize_sndbuf(const int sfd) {
  				      socklen_t intsize = sizeof(int);
  				      int last_good = 0;
  				      int min, max, avg;
  				      int old_size;

  				      /* Start with the default size. */
  				      if (getsockopt(sfd, SOL_SOCKET, SO_SNDBUF, &old_size, &intsize) != 0) {
  				          if (settings.verbose > 0)
  				              perror("getsockopt(SO_SNDBUF)");
  				          return;
  				      }

  				      /* Binary-search for the real maximum. */
  				      min = old_size;
  				      max = MAX_SENDBUF_SIZE;

  				      while (min <= max) {
  				          avg = ((unsigned int)(min + max)) / 2;
  				          if (setsockopt(sfd, SOL_SOCKET, SO_SNDBUF, (void *)&avg, intsize) == 0) {
  				              last_good = avg;
  				              min = avg + 1;
  				          } else {
  				              max = avg - 1;
  				          }
  				      }

  				      if (settings.verbose > 1)
  				          fprintf(stderr, "<%d send buffer was %d, now %d\n", sfd, old_size, last_good);
  				  }
          	
  	          </pre>
  	        </div>
  	      </div>
  	    </div>
  	    <div class="panel panel-default">
  	      <div class="panel-heading">
  	        <h4 class="panel-title">
  	          <a data-toggle="collapse" data-parent="#accordion" href="#server_socket">
  				  static int server_socket(const char *interface,
  				                           int port,
  				                           enum network_transport transport,
  				                           FILE *portnumber_file)
  	          </a>
  	        </h4>
  	      </div>
  	      <div id="server_socket" class="panel-collapse collapse">
  	        <div class="panel-body">
  	          <pre>
  				  /**
  				   * Create a socket and bind it to a specific port number
  				   * @param interface the interface to bind to
  				   * @param port the port number to bind to
  				   * @param transport the transport protocol (TCP / UDP)
  				   * @param portnumber_file A filepointer to write the port numbers to
  				   *        when they are successfully added to the list of ports we
  				   *        listen on.
  				   */
  				  static int server_socket(const char *interface,
  				                           int port,
  				                           enum network_transport transport,
  				                           FILE *portnumber_file) {
  				      int sfd;
  				      struct linger ling = {0, 0};
  				      struct addrinfo *ai;
  				      struct addrinfo *next;
  				      struct addrinfo hints = { .ai_flags = AI_PASSIVE,
  				                                .ai_family = AF_UNSPEC };
  				      char port_buf[NI_MAXSERV];
  				      int error;
  				      int success = 0;
  				      int flags =1;

  				      hints.ai_socktype = IS_UDP(transport) ? SOCK_DGRAM : SOCK_STREAM;

  				      if (port == -1) {
  				          port = 0;
  				      }
  				      snprintf(port_buf, sizeof(port_buf), "%d", port);
  				      error= getaddrinfo(interface, port_buf, &hints, &ai);
  				      if (error != 0) {
  				          if (error != EAI_SYSTEM)
  				            fprintf(stderr, "getaddrinfo(): %s\n", gai_strerror(error));
  				          else
  				            perror("getaddrinfo()");
  				          return 1;
  				      }

  				      for (next= ai; next; next= next->ai_next) {
  				          conn *listen_conn_add;
  				          if ((sfd = new_socket(next)) == -1) {
  				              /* getaddrinfo can return "junk" addresses,
  				               * we make sure at least one works before erroring.
  				               */
  				              if (errno == EMFILE) {
  				                  /* ...unless we're out of fds */
  				                  perror("server_socket");
  				                  exit(EX_OSERR);
  				              }
  				              continue;
  				          }

  				  #ifdef IPV6_V6ONLY
  				          if (next->ai_family == AF_INET6) {
  				              error = setsockopt(sfd, IPPROTO_IPV6, IPV6_V6ONLY, (char *) &flags, sizeof(flags));
  				              if (error != 0) {
  				                  perror("setsockopt");
  				                  close(sfd);
  				                  continue;
  				              }
  				          }
  				  #endif

  				          setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, (void *)&flags, sizeof(flags));
  				          if (IS_UDP(transport)) {
  				              maximize_sndbuf(sfd);
  				          } else {
  				              error = setsockopt(sfd, SOL_SOCKET, SO_KEEPALIVE, (void *)&flags, sizeof(flags));
  				              if (error != 0)
  				                  perror("setsockopt");

  				              error = setsockopt(sfd, SOL_SOCKET, SO_LINGER, (void *)&ling, sizeof(ling));
  				              if (error != 0)
  				                  perror("setsockopt");

  				              error = setsockopt(sfd, IPPROTO_TCP, TCP_NODELAY, (void *)&flags, sizeof(flags));
  				              if (error != 0)
  				                  perror("setsockopt");
  				          }

  				          if (bind(sfd, next->ai_addr, next->ai_addrlen) == -1) {
  				              if (errno != EADDRINUSE) {
  				                  perror("bind()");
  				                  close(sfd);
  				                  freeaddrinfo(ai);
  				                  return 1;
  				              }
  				              close(sfd);
  				              continue;
  				          } else {
  				              success++;
  				              if (!IS_UDP(transport) && listen(sfd, settings.backlog) == -1) {
  				                  perror("listen()");
  				                  close(sfd);
  				                  freeaddrinfo(ai);
  				                  return 1;
  				              }
  				              if (portnumber_file != NULL &&
  				                  (next->ai_addr->sa_family == AF_INET ||
  				                   next->ai_addr->sa_family == AF_INET6)) {
  				                  union {
  				                      struct sockaddr_in in;
  				                      struct sockaddr_in6 in6;
  				                  } my_sockaddr;
  				                  socklen_t len = sizeof(my_sockaddr);
  				                  if (getsockname(sfd, (struct sockaddr*)&my_sockaddr, &len)==0) {
  				                      if (next->ai_addr->sa_family == AF_INET) {
  				                          fprintf(portnumber_file, "%s INET: %u\n",
  				                                  IS_UDP(transport) ? "UDP" : "TCP",
  				                                  ntohs(my_sockaddr.in.sin_port));
  				                      } else {
  				                          fprintf(portnumber_file, "%s INET6: %u\n",
  				                                  IS_UDP(transport) ? "UDP" : "TCP",
  				                                  ntohs(my_sockaddr.in6.sin6_port));
  				                      }
  				                  }
  				              }
  				          }

  				          if (IS_UDP(transport)) {
  				              int c;

  				              for (c = 0; c < settings.num_threads_per_udp; c++) {
  				                  /* this is guaranteed to hit all threads because we round-robin */
  				                  dispatch_conn_new(sfd, conn_read, EV_READ | EV_PERSIST,
  				                                    UDP_READ_BUFFER_SIZE, transport);
  				              }
  				          } else {
  				              if (!(listen_conn_add = conn_new(sfd, conn_listening,
  				                                               EV_READ | EV_PERSIST, 1,
  				                                               transport, main_base))) {
  				                  fprintf(stderr, "failed to create listening connection\n");
  				                  exit(EXIT_FAILURE);
  				              }
  				              listen_conn_add->next = listen_conn;
  				              listen_conn = listen_conn_add;
  				          }
  				      }

  				      freeaddrinfo(ai);

  				      /* Return zero iff we detected no errors in starting up connections */
  				      return success == 0;
  				  }
          	
  	          </pre>
  	        </div>
  	      </div>
  	    </div>
  	    <div class="panel panel-default">
  	      <div class="panel-heading">
  	        <h4 class="panel-title">
  	          <a data-toggle="collapse" data-parent="#accordion" href="#server_socketsTwo">
  				  static int server_sockets(int port, enum network_transport transport,
  				                            FILE *portnumber_file) 
  	          </a>
  	        </h4>
  	      </div>
  	      <div id="server_socketsTwo" class="panel-collapse collapse">
  	        <div class="panel-body">
  	          <pre>
  				  static int server_sockets(int port, enum network_transport transport,
  				                            FILE *portnumber_file) {
  				      if (settings.inter == NULL) {
  				          return server_socket(settings.inter, port, transport, portnumber_file);
  				      } else {
  				          // tokenize them and bind to each one of them..
  				          char *b;
  				          int ret = 0;
  				          char *list = strdup(settings.inter);

  				          if (list == NULL) {
  				              fprintf(stderr, "Failed to allocate memory for parsing server interface string\n");
  				              return 1;
  				          }
  				          for (char *p = strtok_r(list, ";,", &b);
  				               p != NULL;
  				               p = strtok_r(NULL, ";,", &b)) {
  				              int the_port = port;
  				              char *s = strchr(p, ':');
  				              if (s != NULL) {
  				                  *s = '\0';
  				                  ++s;
  				                  if (!safe_strtol(s, &the_port)) {
  				                      fprintf(stderr, "Invalid port number: \"%s\"", s);
  				                      return 1;
  				                  }
  				              }
  				              if (strcmp(p, "*") == 0) {
  				                  p = NULL;
  				              }
  				              ret |= server_socket(p, the_port, transport, portnumber_file);
  				          }
  				          free(list);
  				          return ret;
  				      }
  				  }
          	
  	          </pre>
  	        </div>
  	      </div>
  	    </div>
  	    <div class="panel panel-default">
  	      <div class="panel-heading">
  	        <h4 class="panel-title">
  	          <a data-toggle="collapse" data-parent="#accordion" href="#new_socket_unix">
  	            static int new_socket_unix(void) 
  	          </a>
  	        </h4>
  	      </div>
  	      <div id="new_socket_unix" class="panel-collapse collapse">
  	        <div class="panel-body">
  	          <pre>
  				  static int new_socket_unix(void) {
  				      int sfd;
  				      int flags;

  				      if ((sfd = socket(AF_UNIX, SOCK_STREAM, 0)) == -1) {
  				          perror("socket()");
  				          return -1;
  				      }

  				      if ((flags = fcntl(sfd, F_GETFL, 0)) < 0 ||
  				          fcntl(sfd, F_SETFL, flags | O_NONBLOCK) < 0) {
  				          perror("setting O_NONBLOCK");
  				          close(sfd);
  				          return -1;
  				      }
  				      return sfd;
  				  }
  	          </pre>
  	        </div>
  	      </div>
  	    </div>
  	    <div class="panel panel-default">
  	      <div class="panel-heading">
  	        <h4 class="panel-title">
  	          <a data-toggle="collapse" data-parent="#accordion" href="#server_socket_unix">
  	            static int server_socket_unix(const char *path, int access_mask)
  	          </a>
  	        </h4>
  	      </div>
  	      <div id="server_socket_unix" class="panel-collapse collapse">
  	        <div class="panel-body">
  	          <pre>
  				  static int server_socket_unix(const char *path, int access_mask) {
  				      int sfd;
  				      struct linger ling = {0, 0};
  				      struct sockaddr_un addr;
  				      struct stat tstat;
  				      int flags =1;
  				      int old_umask;

  				      if (!path) {
  				          return 1;
  				      }

  				      if ((sfd = new_socket_unix()) == -1) {
  				          return 1;
  				      }

  				      /*
  				       * Clean up a previous socket file if we left it around
  				       */
  				      if (lstat(path, &tstat) == 0) {
  				          if (S_ISSOCK(tstat.st_mode))
  				              unlink(path);
  				      }

  				      setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, (void *)&flags, sizeof(flags));
  				      setsockopt(sfd, SOL_SOCKET, SO_KEEPALIVE, (void *)&flags, sizeof(flags));
  				      setsockopt(sfd, SOL_SOCKET, SO_LINGER, (void *)&ling, sizeof(ling));

  				      /*
  				       * the memset call clears nonstandard fields in some impementations
  				       * that otherwise mess things up.
  				       */
  				      memset(&addr, 0, sizeof(addr));

  				      addr.sun_family = AF_UNIX;
  				      strncpy(addr.sun_path, path, sizeof(addr.sun_path) - 1);
  				      assert(strcmp(addr.sun_path, path) == 0);
  				      old_umask = umask( ~(access_mask&0777));
  				      if (bind(sfd, (struct sockaddr *)&addr, sizeof(addr)) == -1) {
  				          perror("bind()");
  				          close(sfd);
  				          umask(old_umask);
  				          return 1;
  				      }
  				      umask(old_umask);
  				      if (listen(sfd, settings.backlog) == -1) {
  				          perror("listen()");
  				          close(sfd);
  				          return 1;
  				      }
  				      if (!(listen_conn = conn_new(sfd, conn_listening,
  				                                   EV_READ | EV_PERSIST, 1,
  				                                   local_transport, main_base))) {
  				          fprintf(stderr, "failed to create listening connection\n");
  				          exit(EXIT_FAILURE);
  				      }

  				      return 0;
  				  }
          	
  	          </pre>
  	        </div>
  	      </div>
  	    </div>
  	    <div class="panel panel-default">
  	      <div class="panel-heading">
  	        <h4 class="panel-title">
  	          <a data-toggle="collapse" data-parent="#accordion" href="#cclock_handler">
  	            static void clock_handler(const int fd, const short which, void *arg) 
  	          </a>
  	        </h4>
  	      </div>
  	      <div id="clock_handler" class="panel-collapse collapse">
  	        <div class="panel-body">
  	          <pre>
  				  /* libevent uses a monotonic clock when available for event scheduling. Aside
  				   * from jitter, simply ticking our internal timer here is accurate enough.
  				   * Note that users who are setting explicit dates for expiration times *must*
  				   * ensure their clocks are correct before starting memcached. */
  				  static void clock_handler(const int fd, const short which, void *arg) {
  				      struct timeval t = {.tv_sec = 1, .tv_usec = 0};
  				      static bool initialized = false;
  				  #if defined(HAVE_CLOCK_GETTIME) && defined(CLOCK_MONOTONIC)
  				      static bool monotonic = false;
  				      static time_t monotonic_start;
  				  #endif

  				      if (initialized) {
  				          /* only delete the event if it's actually there. */
  				          evtimer_del(&clockevent);
  				      } else {
  				          initialized = true;
  				          /* process_started is initialized to time() - 2. We initialize to 1 so
  				           * flush_all won't underflow during tests. */
  				  #if defined(HAVE_CLOCK_GETTIME) && defined(CLOCK_MONOTONIC)
  				          struct timespec ts;
  				          if (clock_gettime(CLOCK_MONOTONIC, &ts) == 0) {
  				              monotonic = true;
  				              monotonic_start = ts.tv_sec - 2;
  				          }
  				  #endif
  				      }

  				      evtimer_set(&clockevent, clock_handler, 0);
  				      event_base_set(main_base, &clockevent);
  				      evtimer_add(&clockevent, &t);

  				  #if defined(HAVE_CLOCK_GETTIME) && defined(CLOCK_MONOTONIC)
  				      if (monotonic) {
  				          struct timespec ts;
  				          if (clock_gettime(CLOCK_MONOTONIC, &ts) == -1)
  				              return;
  				          current_time = (rel_time_t) (ts.tv_sec - monotonic_start);
  				          return;
  				      }
  				  #endif
  				      {
  				          struct timeval tv;
  				          gettimeofday(&tv, NULL);
  				          current_time = (rel_time_t) (tv.tv_sec - process_started);
  				      }
  				  }
          	
  	          </pre>
  	        </div>
  	      </div>
  	    </div>
  	    <div class="panel panel-default">
  	      <div class="panel-heading">
  	        <h4 class="panel-title">
  	          <a data-toggle="collapse" data-parent="#accordion" href="#save_pid">
  	            static void save_pid(const char *pid_file)
  	          </a>
  	        </h4>
  	      </div>
  	      <div id="save_pid" class="panel-collapse collapse">
  	        <div class="panel-body">
  	          <pre>
  				  static void save_pid(const char *pid_file) {
  				      FILE *fp;
  				      if (access(pid_file, F_OK) == 0) {
  				          if ((fp = fopen(pid_file, "r")) != NULL) {
  				              char buffer[1024];
  				              if (fgets(buffer, sizeof(buffer), fp) != NULL) {
  				                  unsigned int pid;
  				                  if (safe_strtoul(buffer, &pid) && kill((pid_t)pid, 0) == 0) {
  				                      fprintf(stderr, "WARNING: The pid file contained the following (running) pid: %u\n", pid);
  				                  }
  				              }
  				              fclose(fp);
  				          }
  				      }

  				      if ((fp = fopen(pid_file, "w")) == NULL) {
  				          vperror("Could not open the pid file %s for writing", pid_file);
  				          return;
  				      }

  				      fprintf(fp,"%ld\n", (long)getpid());
  				      if (fclose(fp) == -1) {
  				          vperror("Could not close the pid file %s", pid_file);
  				      }
  				  }
          	
  	          </pre>
  	        </div>
  	      </div>
  	    </div>
  	    <div class="panel panel-default">
  	      <div class="panel-heading">
  	        <h4 class="panel-title">
  	          <a data-toggle="collapse" data-parent="#accordion" href="#remove_pidfile">
  	            static void remove_pidfile(const char *pid_file)
  	          </a>
  	        </h4>
  	      </div>
  	      <div id="remove_pidfile" class="panel-collapse collapse">
  	        <div class="panel-body">
  	          <pre>
  				  static void remove_pidfile(const char *pid_file) {
  				    if (pid_file == NULL)
  				        return;

  				    if (unlink(pid_file) != 0) {
  				        vperror("Could not remove the pid file %s", pid_file);
  				    }

  				  }
  	          </pre>
  	        </div>
  	      </div>
  	    </div>
  	    <div class="panel panel-default">
  	      <div class="panel-heading">
  	        <h4 class="panel-title">
  	          <a data-toggle="collapse" data-parent="#accordion" href="#sig_handler">
  	            static void sig_handler(const int sig)
  	          </a>
  	        </h4>
  	      </div>
  	      <div id="collapseTwo" class="panel-collapse collapse">
  	        <div class="panel-body">
  	          <pre>
  				  static void sig_handler(const int sig) {
  				      printf("SIGINT handled.\n");
  				      exit(EXIT_SUCCESS);
  				  }
  	          </pre>
  	        </div>
  	      </div>
  	    </div>
  	    <div class="panel panel-default">
  	      <div class="panel-heading">
  	        <h4 class="panel-title">
  	          <a data-toggle="collapse" data-parent="#accordion" href="#sigignore">
  	            static int sigignore(int sig)
  	          </a>
  	        </h4>
  	      </div>
  	      <div id="sigignore" class="panel-collapse collapse">
  	        <div class="panel-body">
  	          <pre>
  				  #ifndef HAVE_SIGIGNORE
  				  static int sigignore(int sig) {
  				      struct sigaction sa = { .sa_handler = SIG_IGN, .sa_flags = 0 };

  				      if (sigemptyset(&sa.sa_mask) == -1 || sigaction(sig, &sa, 0) == -1) {
  				          return -1;
  				      }
  				      return 0;
  				  }
  				  #endif
          	
  	          </pre>
  	        </div>
  	      </div>
  	    </div>
  	    <div class="panel panel-default">
  	      <div class="panel-heading">
  	        <h4 class="panel-title">
  	          <a data-toggle="collapse" data-parent="#accordion" href="#enable_large_pages">
  	            static int enable_large_pages(void) 
  	          </a>
  	        </h4>
  	      </div>
  	      <div id="enable_large_pages" class="panel-collapse collapse">
  	        <div class="panel-body">
  	          <pre>
  				  /*
  				   * On systems that supports multiple page sizes we may reduce the
  				   * number of TLB-misses by using the biggest available page size
  				   */
  				  static int enable_large_pages(void) {
  				  #if defined(HAVE_GETPAGESIZES) && defined(HAVE_MEMCNTL)
  				      int ret = -1;
  				      size_t sizes[32];
  				      int avail = getpagesizes(sizes, 32);
  				      if (avail != -1) {
  				          size_t max = sizes[0];
  				          struct memcntl_mha arg = {0};
  				          int ii;

  				          for (ii = 1; ii < avail; ++ii) {
  				              if (max < sizes[ii]) {
  				                  max = sizes[ii];
  				              }
  				          }

  				          arg.mha_flags   = 0;
  				          arg.mha_pagesize = max;
  				          arg.mha_cmd = MHA_MAPSIZE_BSSBRK;

  				          if (memcntl(0, 0, MC_HAT_ADVISE, (caddr_t)&arg, 0, 0) == -1) {
  				              fprintf(stderr, "Failed to set large pages: %s\n",
  				                      strerror(errno));
  				              fprintf(stderr, "Will use default page size\n");
  				          } else {
  				              ret = 0;
  				          }
  				      } else {
  				          fprintf(stderr, "Failed to get supported pagesizes: %s\n",
  				                  strerror(errno));
  				          fprintf(stderr, "Will use default page size\n");
  				      }

  				      return ret;
  				  #else
  				      return -1;
  				  #endif
  				  }
          	
  	          </pre>
  	        </div>
  	      </div>
  	    </div>
  	    <div class="panel panel-default">
  	      <div class="panel-heading">
  	        <h4 class="panel-title">
  	          <a data-toggle="collapse" data-parent="#accordion" href="#sanitycheck">
  	            static bool sanitycheck(void) 
  	          </a>
  	        </h4>
  	      </div>
  	      <div id="sanitycheck" class="panel-collapse collapse">
  	        <div class="panel-body">
  	          <pre>
  				  /**
  				   * Do basic sanity check of the runtime environment
  				   * @return true if no errors found, false if we can't use this env
  				   */
  				  static bool sanitycheck(void) {
  				      /* One of our biggest problems is old and bogus libevents */
  				      const char *ever = event_get_version();
  				      if (ever != NULL) {
  				          if (strncmp(ever, "1.", 2) == 0) {
  				              /* Require at least 1.3 (that's still a couple of years old) */
  				              if ((ever[2] == '1' || ever[2] == '2') && !isdigit(ever[3])) {
  				                  fprintf(stderr, "You are using libevent %s.\nPlease upgrade to"
  				                          " a more recent version (1.3 or newer)\n",
  				                          event_get_version());
  				                  return false;
  				              }
  				          }
  				      }

  				      return true;
  				  }
          	
  	          </pre>
  	        </div>
  	      </div>
  	    </div>
  	    <div class="panel panel-default">
  	      <div class="panel-heading">
  	        <h4 class="panel-title">
  	          <a data-toggle="collapse" data-parent="#accordion" href="#main">
  	            int main (int argc, char **argv)
  	          </a>
  	        </h4>
  	      </div>
  	      <div id="main" class="panel-collapse collapse">
  	        <div class="panel-body">
  	          <pre>
  				  int main (int argc, char **argv) {
  				      int c;
  				      bool lock_memory = false;
  				      bool do_daemonize = false;
  				      bool preallocate = false;
  				      int maxcore = 0;
  				      char *username = NULL;
  				      char *pid_file = NULL;
  				      struct passwd *pw;
  				      struct rlimit rlim;
  				      char unit = '\0';
  				      int size_max = 0;
  				      int retval = EXIT_SUCCESS;
  				      /* listening sockets */
  				      static int *l_socket = NULL;

  				      /* udp socket */
  				      static int *u_socket = NULL;
  				      bool protocol_specified = false;
  				      bool tcp_specified = false;
  				      bool udp_specified = false;

  				      char *subopts;
  				      char *subopts_value;
  				      enum {
  				          MAXCONNS_FAST = 0,
  				          HASHPOWER_INIT,
  				          SLAB_REASSIGN,
  				          SLAB_AUTOMOVE
  				      };
  				      char *const subopts_tokens[] = {
  				          [MAXCONNS_FAST] = "maxconns_fast",
  				          [HASHPOWER_INIT] = "hashpower",
  				          [SLAB_REASSIGN] = "slab_reassign",
  				          [SLAB_AUTOMOVE] = "slab_automove",
  				          NULL
  				      };

  				      if (!sanitycheck()) {
  				          return EX_OSERR;
  				      }

  				      /* handle SIGINT */
  				      signal(SIGINT, sig_handler);

  				      /* init settings */
  				      settings_init();

  				      /* set stderr non-buffering (for running under, say, daemontools) */
  				      setbuf(stderr, NULL);

  				      /* process arguments */
  				      while (-1 != (c = getopt(argc, argv,
  				            "a:"  /* access mask for unix socket */
  				            "A"  /* enable admin shutdown commannd */
  				            "p:"  /* TCP port number to listen on */
  				            "s:"  /* unix socket path to listen on */
  				            "U:"  /* UDP port number to listen on */
  				            "m:"  /* max memory to use for items in megabytes */
  				            "M"   /* return error on memory exhausted */
  				            "c:"  /* max simultaneous connections */
  				            "k"   /* lock down all paged memory */
  				            "hi"  /* help, licence info */
  				            "r"   /* maximize core file limit */
  				            "v"   /* verbose */
  				            "d"   /* daemon mode */
  				            "l:"  /* interface to listen on */
  				            "u:"  /* user identity to run as */
  				            "P:"  /* save PID in file */
  				            "f:"  /* factor? */
  				            "n:"  /* minimum space allocated for key+value+flags */
  				            "t:"  /* threads */
  				            "D:"  /* prefix delimiter? */
  				            "L"   /* Large memory pages */
  				            "R:"  /* max requests per event */
  				            "C"   /* Disable use of CAS */
  				            "b:"  /* backlog queue limit */
  				            "B:"  /* Binding protocol */
  				            "I:"  /* Max item size */
  				            "S"   /* Sasl ON */
  				            "o:"  /* Extended generic options */
  				          ))) {
  				          switch (c) {
  				          case 'A':
  				              /* enables "shutdown" command */
  				              settings.shutdown_command = true;
  				              break;

  				          case 'a':
  				              /* access for unix domain socket, as octal mask (like chmod)*/
  				              settings.access= strtol(optarg,NULL,8);
  				              break;

  				          case 'U':
  				              settings.udpport = atoi(optarg);
  				              udp_specified = true;
  				              break;
  				          case 'p':
  				              settings.port = atoi(optarg);
  				              tcp_specified = true;
  				              break;
  				          case 's':
  				              settings.socketpath = optarg;
  				              break;
  				          case 'm':
  				              settings.maxbytes = ((size_t)atoi(optarg)) * 1024 * 1024;
  				              break;
  				          case 'M':
  				              settings.evict_to_free = 0;
  				              break;
  				          case 'c':
  				              settings.maxconns = atoi(optarg);
  				              break;
  				          case 'h':
  				              usage();
  				              exit(EXIT_SUCCESS);
  				          case 'i':
  				              usage_license();
  				              exit(EXIT_SUCCESS);
  				          case 'k':
  				              lock_memory = true;
  				              break;
  				          case 'v':
  				              settings.verbose++;
  				              break;
  				          case 'l':
  				              if (settings.inter != NULL) {
  				                  size_t len = strlen(settings.inter) + strlen(optarg) + 2;
  				                  char *p = malloc(len);
  				                  if (p == NULL) {
  				                      fprintf(stderr, "Failed to allocate memory\n");
  				                      return 1;
  				                  }
  				                  snprintf(p, len, "%s,%s", settings.inter, optarg);
  				                  free(settings.inter);
  				                  settings.inter = p;
  				              } else {
  				                  settings.inter= strdup(optarg);
  				              }
  				              break;
  				          case 'd':
  				              do_daemonize = true;
  				              break;
  				          case 'r':
  				              maxcore = 1;
  				              break;
  				          case 'R':
  				              settings.reqs_per_event = atoi(optarg);
  				              if (settings.reqs_per_event == 0) {
  				                  fprintf(stderr, "Number of requests per event must be greater than 0\n");
  				                  return 1;
  				              }
  				              break;
  				          case 'u':
  				              username = optarg;
  				              break;
  				          case 'P':
  				              pid_file = optarg;
  				              break;
  				          case 'f':
  				              settings.factor = atof(optarg);
  				              if (settings.factor <= 1.0) {
  				                  fprintf(stderr, "Factor must be greater than 1\n");
  				                  return 1;
  				              }
  				              break;
  				          case 'n':
  				              settings.chunk_size = atoi(optarg);
  				              if (settings.chunk_size == 0) {
  				                  fprintf(stderr, "Chunk size must be greater than 0\n");
  				                  return 1;
  				              }
  				              break;
  				          case 't':
  				              settings.num_threads = atoi(optarg);
  				              if (settings.num_threads <= 0) {
  				                  fprintf(stderr, "Number of threads must be greater than 0\n");
  				                  return 1;
  				              }
  				              /* There're other problems when you get above 64 threads.
  				               * In the future we should portably detect # of cores for the
  				               * default.
  				               */
  				              if (settings.num_threads > 64) {
  				                  fprintf(stderr, "WARNING: Setting a high number of worker"
  				                                  "threads is not recommended.\n"
  				                                  " Set this value to the number of cores in"
  				                                  " your machine or less.\n");
  				              }
  				              break;
  				          case 'D':
  				              if (! optarg || ! optarg[0]) {
  				                  fprintf(stderr, "No delimiter specified\n");
  				                  return 1;
  				              }
  				              settings.prefix_delimiter = optarg[0];
  				              settings.detail_enabled = 1;
  				              break;
  				          case 'L' :
  				              if (enable_large_pages() == 0) {
  				                  preallocate = true;
  				              } else {
  				                  fprintf(stderr, "Cannot enable large pages on this system\n"
  				                      "(There is no Linux support as of this version)\n");
  				                  return 1;
  				              }
  				              break;
  				          case 'C' :
  				              settings.use_cas = false;
  				              break;
  				          case 'b' :
  				              settings.backlog = atoi(optarg);
  				              break;
  				          case 'B':
  				              protocol_specified = true;
  				              if (strcmp(optarg, "auto") == 0) {
  				                  settings.binding_protocol = negotiating_prot;
  				              } else if (strcmp(optarg, "binary") == 0) {
  				                  settings.binding_protocol = binary_prot;
  				              } else if (strcmp(optarg, "ascii") == 0) {
  				                  settings.binding_protocol = ascii_prot;
  				              } else {
  				                  fprintf(stderr, "Invalid value for binding protocol: %s\n"
  				                          " -- should be one of auto, binary, or ascii\n", optarg);
  				                  exit(EX_USAGE);
  				              }
  				              break;
  				          case 'I':
  				              unit = optarg[strlen(optarg)-1];
  				              if (unit == 'k' || unit == 'm' ||
  				                  unit == 'K' || unit == 'M') {
  				                  optarg[strlen(optarg)-1] = '\0';
  				                  size_max = atoi(optarg);
  				                  if (unit == 'k' || unit == 'K')
  				                      size_max *= 1024;
  				                  if (unit == 'm' || unit == 'M')
  				                      size_max *= 1024 * 1024;
  				                  settings.item_size_max = size_max;
  				              } else {
  				                  settings.item_size_max = atoi(optarg);
  				              }
  				              if (settings.item_size_max < 1024) {
  				                  fprintf(stderr, "Item max size cannot be less than 1024 bytes.\n");
  				                  return 1;
  				              }
  				              if (settings.item_size_max > 1024 * 1024 * 128) {
  				                  fprintf(stderr, "Cannot set item size limit higher than 128 mb.\n");
  				                  return 1;
  				              }
  				              if (settings.item_size_max > 1024 * 1024) {
  				                  fprintf(stderr, "WARNING: Setting item max size above 1MB is not"
  				                      " recommended!\n"
  				                      " Raising this limit increases the minimum memory requirements\n"
  				                      " and will decrease your memory efficiency.\n"
  				                  );
  				              }
  				              break;
  				          case 'S': /* set Sasl authentication to true. Default is false */
  				  #ifndef ENABLE_SASL
  				              fprintf(stderr, "This server is not built with SASL support.\n");
  				              exit(EX_USAGE);
  				  #endif
  				              settings.sasl = true;
  				              break;
  				          case 'o': /* It's sub-opts time! */
  				              subopts = optarg;

  				              while (*subopts != '\0') {

  				              switch (getsubopt(&subopts, subopts_tokens, &subopts_value)) {
  				              case MAXCONNS_FAST:
  				                  settings.maxconns_fast = true;
  				                  break;
  				              case HASHPOWER_INIT:
  				                  if (subopts_value == NULL) {
  				                      fprintf(stderr, "Missing numeric argument for hashpower\n");
  				                      return 1;
  				                  }
  				                  settings.hashpower_init = atoi(subopts_value);
  				                  if (settings.hashpower_init < 12) {
  				                      fprintf(stderr, "Initial hashtable multiplier of %d is too low\n",
  				                          settings.hashpower_init);
  				                      return 1;
  				                  } else if (settings.hashpower_init > 64) {
  				                      fprintf(stderr, "Initial hashtable multiplier of %d is too high\n"
  				                          "Choose a value based on \"STAT hash_power_level\" from a running instance\n",
  				                          settings.hashpower_init);
  				                      return 1;
  				                  }
  				                  break;
  				              case SLAB_REASSIGN:
  				                  settings.slab_reassign = true;
  				                  break;
  				              case SLAB_AUTOMOVE:
  				                  if (subopts_value == NULL) {
  				                      settings.slab_automove = 1;
  				                      break;
  				                  }
  				                  settings.slab_automove = atoi(subopts_value);
  				                  if (settings.slab_automove < 0 || settings.slab_automove > 2) {
  				                      fprintf(stderr, "slab_automove must be between 0 and 2\n");
  				                      return 1;
  				                  }
  				                  break;
  				              default:
  				                  printf("Illegal suboption \"%s\"\n", subopts_value);
  				                  return 1;
  				              }

  				              }
  				              break;
  				          default:
  				              fprintf(stderr, "Illegal argument \"%c\"\n", c);
  				              return 1;
  				          }
  				      }

  				      /*
  				       * Use one workerthread to serve each UDP port if the user specified
  				       * multiple ports
  				       */
  				      if (settings.inter != NULL && strchr(settings.inter, ',')) {
  				          settings.num_threads_per_udp = 1;
  				      } else {
  				          settings.num_threads_per_udp = settings.num_threads;
  				      }

  				      if (settings.sasl) {
  				          if (!protocol_specified) {
  				              settings.binding_protocol = binary_prot;
  				          } else {
  				              if (settings.binding_protocol != binary_prot) {
  				                  fprintf(stderr, "ERROR: You cannot allow the ASCII protocol while using SASL.\n");
  				                  exit(EX_USAGE);
  				              }
  				          }
  				      }

  				      if (tcp_specified && !udp_specified) {
  				          settings.udpport = settings.port;
  				      } else if (udp_specified && !tcp_specified) {
  				          settings.port = settings.udpport;
  				      }

  				      if (maxcore != 0) {
  				          struct rlimit rlim_new;
  				          /*
  				           * First try raising to infinity; if that fails, try bringing
  				           * the soft limit to the hard.
  				           */
  				          if (getrlimit(RLIMIT_CORE, &rlim) == 0) {
  				              rlim_new.rlim_cur = rlim_new.rlim_max = RLIM_INFINITY;
  				              if (setrlimit(RLIMIT_CORE, &rlim_new)!= 0) {
  				                  /* failed. try raising just to the old max */
  				                  rlim_new.rlim_cur = rlim_new.rlim_max = rlim.rlim_max;
  				                  (void)setrlimit(RLIMIT_CORE, &rlim_new);
  				              }
  				          }
  				          /*
  				           * getrlimit again to see what we ended up with. Only fail if
  				           * the soft limit ends up 0, because then no core files will be
  				           * created at all.
  				           */

  				          if ((getrlimit(RLIMIT_CORE, &rlim) != 0) || rlim.rlim_cur == 0) {
  				              fprintf(stderr, "failed to ensure corefile creation\n");
  				              exit(EX_OSERR);
  				          }
  				      }

  				      /*
  				       * If needed, increase rlimits to allow as many connections
  				       * as needed.
  				       */

  				      if (getrlimit(RLIMIT_NOFILE, &rlim) != 0) {
  				          fprintf(stderr, "failed to getrlimit number of files\n");
  				          exit(EX_OSERR);
  				      } else {
  				          rlim.rlim_cur = settings.maxconns;
  				          rlim.rlim_max = settings.maxconns;
  				          if (setrlimit(RLIMIT_NOFILE, &rlim) != 0) {
  				              fprintf(stderr, "failed to set rlimit for open files. Try starting as root or requesting smaller maxconns value.\n");
  				              exit(EX_OSERR);
  				          }
  				      }

  				      /* lose root privileges if we have them */
  				      if (getuid() == 0 || geteuid() == 0) {
  				          if (username == 0 || *username == '\0') {
  				              fprintf(stderr, "can't run as root without the -u switch\n");
  				              exit(EX_USAGE);
  				          }
  				          if ((pw = getpwnam(username)) == 0) {
  				              fprintf(stderr, "can't find the user %s to switch to\n", username);
  				              exit(EX_NOUSER);
  				          }
  				          if (setgid(pw->pw_gid) < 0 || setuid(pw->pw_uid) < 0) {
  				              fprintf(stderr, "failed to assume identity of user %s\n", username);
  				              exit(EX_OSERR);
  				          }
  				      }

  				      /* Initialize Sasl if -S was specified */
  				      if (settings.sasl) {
  				          init_sasl();
  				      }

  				      /* daemonize if requested */
  				      /* if we want to ensure our ability to dump core, don't chdir to / */
  				      if (do_daemonize) {
  				          if (sigignore(SIGHUP) == -1) {
  				              perror("Failed to ignore SIGHUP");
  				          }
  				          if (daemonize(maxcore, settings.verbose) == -1) {
  				              fprintf(stderr, "failed to daemon() in order to daemonize\n");
  				              exit(EXIT_FAILURE);
  				          }
  				      }

  				      /* lock paged memory if needed */
  				      if (lock_memory) {
  				  #ifdef HAVE_MLOCKALL
  				          int res = mlockall(MCL_CURRENT | MCL_FUTURE);
  				          if (res != 0) {
  				              fprintf(stderr, "warning: -k invalid, mlockall() failed: %s\n",
  				                      strerror(errno));
  				          }
  				  #else
  				          fprintf(stderr, "warning: -k invalid, mlockall() not supported on this platform.  proceeding without.\n");
  				  #endif
  				      }

  				      /* initialize main thread libevent instance */
  				      main_base = event_init();

  				      /* initialize other stuff */
  				      stats_init();
  				      assoc_init(settings.hashpower_init);
  				      conn_init();
  				      slabs_init(settings.maxbytes, settings.factor, preallocate);

  				      /*
  				       * ignore SIGPIPE signals; we can use errno == EPIPE if we
  				       * need that information
  				       */
  				      if (sigignore(SIGPIPE) == -1) {
  				          perror("failed to ignore SIGPIPE; sigaction");
  				          exit(EX_OSERR);
  				      }
  				      /* start up worker threads if MT mode */
  				      thread_init(settings.num_threads, main_base);

  				      if (start_assoc_maintenance_thread() == -1) {
  				          exit(EXIT_FAILURE);
  				      }

  				      if (settings.slab_reassign &&
  				          start_slab_maintenance_thread() == -1) {
  				          exit(EXIT_FAILURE);
  				      }

  				      /* initialise clock event */
  				      clock_handler(0, 0, 0);

  				      /* create unix mode sockets after dropping privileges */
  				      if (settings.socketpath != NULL) {
  				          errno = 0;
  				          if (server_socket_unix(settings.socketpath,settings.access)) {
  				              vperror("failed to listen on UNIX socket: %s", settings.socketpath);
  				              exit(EX_OSERR);
  				          }
  				      }

  				      /* create the listening socket, bind it, and init */
  				      if (settings.socketpath == NULL) {
  				          const char *portnumber_filename = getenv("MEMCACHED_PORT_FILENAME");
  				          char temp_portnumber_filename[PATH_MAX];
  				          FILE *portnumber_file = NULL;

  				          if (portnumber_filename != NULL) {
  				              snprintf(temp_portnumber_filename,
  				                       sizeof(temp_portnumber_filename),
  				                       "%s.lck", portnumber_filename);

  				              portnumber_file = fopen(temp_portnumber_filename, "a");
  				              if (portnumber_file == NULL) {
  				                  fprintf(stderr, "Failed to open \"%s\": %s\n",
  				                          temp_portnumber_filename, strerror(errno));
  				              }
  				          }

  				          errno = 0;
  				          if (settings.port && server_sockets(settings.port, tcp_transport,
  				                                             portnumber_file)) {
  				              vperror("failed to listen on TCP port %d", settings.port);
  				              exit(EX_OSERR);
  				          }

  				          /*
  				           * initialization order: first create the listening sockets
  				           * (may need root on low ports), then drop root if needed,
  				           * then daemonise if needed, then init libevent (in some cases
  				           * descriptors created by libevent wouldn't survive forking).
  				           */

  				          /* create the UDP listening socket and bind it */
  				          errno = 0;
  				          if (settings.udpport && server_sockets(settings.udpport, udp_transport,
  				                                                portnumber_file)) {
  				              vperror("failed to listen on UDP port %d", settings.udpport);
  				              exit(EX_OSERR);
  				          }

  				          if (portnumber_file) {
  				              fclose(portnumber_file);
  				              rename(temp_portnumber_filename, portnumber_filename);
  				          }
  				      }

  				      /* Give the sockets a moment to open. I know this is dumb, but the error
  				       * is only an advisory.
  				       */
  				      usleep(1000);
  				      if (stats.curr_conns + stats.reserved_fds >= settings.maxconns - 1) {
  				          fprintf(stderr, "Maxconns setting is too low, use -c to increase.\n");
  				          exit(EXIT_FAILURE);
  				      }

  				      if (pid_file != NULL) {
  				          save_pid(pid_file);
  				      }

  				      /* Drop privileges no longer needed */
  				      drop_privileges();

  				      /* enter the event loop */
  				      if (event_base_loop(main_base, 0) != 0) {
  				          retval = EXIT_FAILURE;
  				      }

  				      stop_assoc_maintenance_thread();

  				      /* remove the PID file if we're a daemon */
  				      if (do_daemonize)
  				          remove_pidfile(pid_file);
  				      /* Clean up strdup() call for bind() address */
  				      if (settings.inter)
  				        free(settings.inter);
  				      if (l_socket)
  				        free(l_socket);
  				      if (u_socket)
  				        free(u_socket);

  				      return retval;
  				  }
          	
  	          </pre>
  	        </div>
  	      </div>
  	    </div>
	    <div class="panel panel-default">
	      <div class="panel-heading">
	        <h4 class="panel-title">
	          <a data-toggle="collapse" data-parent="#accordion" href="#process_get_command">
	            static inline void process_get_command(conn *c, token_t *tokens, size_t ntokens, bool return_cas)
	          </a>
	        </h4>
	      </div>
	      <div id="process_get_command" class="panel-collapse collapse">
	        <div class="panel-body">
	          <pre>
				  /* ntokens is overwritten here... shrug.. */
				  static inline void process_get_command(conn *c, token_t *tokens, size_t ntokens, bool return_cas) {
				      char *key;
				      size_t nkey;
				      int i = 0;
				      item *it;
				      token_t *key_token = &tokens[KEY_TOKEN];
				      char *suffix;
				      assert(c != NULL);

				      do {
				          while(key_token->length != 0) {

				              key = key_token->value;
				              nkey = key_token->length;

				              if(nkey > KEY_MAX_LENGTH) {
				                  out_string(c, "CLIENT_ERROR bad command line format");
				                  return;
				              }

				              it = item_get(key, nkey);
				              if (settings.detail_enabled) {
				                  stats_prefix_record_get(key, nkey, NULL != it);
				              }
				              if (it) {
				                  if (i >= c->isize) {
				                      item **new_list = realloc(c->ilist, sizeof(item *) * c->isize * 2);
				                      if (new_list) {
				                          c->isize *= 2;
				                          c->ilist = new_list;
				                      } else {
				                          item_remove(it);
				                          break;
				                      }
				                  }

				                  /*
				                   * Construct the response. Each hit adds three elements to the
				                   * outgoing data list:
				                   *   "VALUE "
				                   *   key
				                   *   " " + flags + " " + data length + "\r\n" + data (with \r\n)
				                   */

				                  if (return_cas)
				                  {
				                    MEMCACHED_COMMAND_GET(c->sfd, ITEM_key(it), it->nkey,
				                                          it->nbytes, ITEM_get_cas(it));
				                    /* Goofy mid-flight realloc. */
				                    if (i >= c->suffixsize) {
				                      char **new_suffix_list = realloc(c->suffixlist,
				                                             sizeof(char *) * c->suffixsize * 2);
				                      if (new_suffix_list) {
				                          c->suffixsize *= 2;
				                          c->suffixlist  = new_suffix_list;
				                      } else {
				                          item_remove(it);
				                          break;
				                      }
				                    }

				                    suffix = cache_alloc(c->thread->suffix_cache);
				                    if (suffix == NULL) {
				                      out_string(c, "SERVER_ERROR out of memory making CAS suffix");
				                      item_remove(it);
				                      return;
				                    }
				                    *(c->suffixlist + i) = suffix;
				                    int suffix_len = snprintf(suffix, SUFFIX_SIZE,
				                                              " %llu\r\n",
				                                              (unsigned long long)ITEM_get_cas(it));
				                    if (add_iov(c, "VALUE ", 6) != 0 ||
				                        add_iov(c, ITEM_key(it), it->nkey) != 0 ||
				                        add_iov(c, ITEM_suffix(it), it->nsuffix - 2) != 0 ||
				                        add_iov(c, suffix, suffix_len) != 0 ||
				                        add_iov(c, ITEM_data(it), it->nbytes) != 0)
				                        {
				                            item_remove(it);
				                            break;
				                        }
				                  }
				                  else
				                  {
				                    MEMCACHED_COMMAND_GET(c->sfd, ITEM_key(it), it->nkey,
				                                          it->nbytes, ITEM_get_cas(it));
				                    if (add_iov(c, "VALUE ", 6) != 0 ||
				                        add_iov(c, ITEM_key(it), it->nkey) != 0 ||
				                        add_iov(c, ITEM_suffix(it), it->nsuffix + it->nbytes) != 0)
				                        {
				                            item_remove(it);
				                            break;
				                        }
				                  }


				                  if (settings.verbose > 1)
				                      fprintf(stderr, ">%d sending key %s\n", c->sfd, ITEM_key(it));

				                  /* item_get() has incremented it->refcount for us */
				                  pthread_mutex_lock(&c->thread->stats.mutex);
				                  c->thread->stats.slab_stats[it->slabs_clsid].get_hits++;
				                  c->thread->stats.get_cmds++;
				                  pthread_mutex_unlock(&c->thread->stats.mutex);
				                  item_update(it);
				                  *(c->ilist + i) = it;
				                  i++;

				              } else {
				                  pthread_mutex_lock(&c->thread->stats.mutex);
				                  c->thread->stats.get_misses++;
				                  c->thread->stats.get_cmds++;
				                  pthread_mutex_unlock(&c->thread->stats.mutex);
				                  MEMCACHED_COMMAND_GET(c->sfd, key, nkey, -1, 0);
				              }

				              key_token++;
				          }

				          /*
				           * If the command string hasn't been fully processed, get the next set
				           * of tokens.
				           */
				          if(key_token->value != NULL) {
				              ntokens = tokenize_command(key_token->value, tokens, MAX_TOKENS);
				              key_token = tokens;
				          }

				      } while(key_token->value != NULL);

				      c->icurr = c->ilist;
				      c->ileft = i;
				      if (return_cas) {
				          c->suffixcurr = c->suffixlist;
				          c->suffixleft = i;
				      }

				      if (settings.verbose > 1)
				          fprintf(stderr, ">%d END\n", c->sfd);

				      /*
				          If the loop was terminated because of out-of-memory, it is not
				          reliable to add END\r\n to the buffer, because it might not end
				          in \r\n. So we send SERVER_ERROR instead.
				      */
				      if (key_token->value != NULL || add_iov(c, "END\r\n", 5) != 0
				          || (IS_UDP(c->transport) && build_udp_headers(c) != 0)) {
				          out_string(c, "SERVER_ERROR out of memory writing get response");
				      }
				      else {
				          conn_set_state(c, conn_mwrite);
				          c->msgcurr = 0;
				      }

				      return;
				  }
	          	
	          </pre>
	        </div>
	      </div>
	    </div>
	    <div class="panel panel-default">
	      <div class="panel-heading">
	        <h4 class="panel-title">
	          <a data-toggle="collapse" data-parent="#accordion" href="#process_update_command">
	            static void process_update_command(conn *c, token_t *tokens, const size_t ntokens, int comm, bool handle_cas)
	          </a>
	        </h4>
	      </div>
	      <div id="process_update_command" class="panel-collapse collapse">
	        <div class="panel-body">
	          <pre>
				  static void process_update_command(conn *c, token_t *tokens, const size_t ntokens, int comm, bool handle_cas) {
				      char *key;
				      size_t nkey;
				      unsigned int flags;
				      int32_t exptime_int = 0;
				      time_t exptime;
				      int vlen;
				      uint64_t req_cas_id=0;
				      item *it;

				      assert(c != NULL);

				      set_noreply_maybe(c, tokens, ntokens);

				      if (tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {
				          out_string(c, "CLIENT_ERROR bad command line format");
				          return;
				      }

				      key = tokens[KEY_TOKEN].value;
				      nkey = tokens[KEY_TOKEN].length;

				      if (! (safe_strtoul(tokens[2].value, (uint32_t *)&flags)
				             && safe_strtol(tokens[3].value, &exptime_int)
				             && safe_strtol(tokens[4].value, (int32_t *)&vlen))) {
				          out_string(c, "CLIENT_ERROR bad command line format");
				          return;
				      }

				      /* Ubuntu 8.04 breaks when I pass exptime to safe_strtol */
				      exptime = exptime_int;

				      /* Negative exptimes can underflow and end up immortal. realtime() will
				         immediately expire values that are greater than REALTIME_MAXDELTA, but less
				         than process_started, so lets aim for that. */
				      if (exptime < 0)
				          exptime = REALTIME_MAXDELTA + 1;

				      // does cas value exist?
				      if (handle_cas) {
				          if (!safe_strtoull(tokens[5].value, &req_cas_id)) {
				              out_string(c, "CLIENT_ERROR bad command line format");
				              return;
				          }
				      }

				      vlen += 2;
				      if (vlen < 0 || vlen - 2 < 0) {
				          out_string(c, "CLIENT_ERROR bad command line format");
				          return;
				      }

				      if (settings.detail_enabled) {
				          stats_prefix_record_set(key, nkey);
				      }

				      it = item_alloc(key, nkey, flags, realtime(exptime), vlen);

				      if (it == 0) {
				          if (! item_size_ok(nkey, flags, vlen))
				              out_string(c, "SERVER_ERROR object too large for cache");
				          else
				              out_string(c, "SERVER_ERROR out of memory storing object");
				          /* swallow the data line */
				          c->write_and_go = conn_swallow;
				          c->sbytes = vlen;

				          /* Avoid stale data persisting in cache because we failed alloc.
				           * Unacceptable for SET. Anywhere else too? */
				          if (comm == NREAD_SET) {
				              it = item_get(key, nkey);
				              if (it) {
				                  item_unlink(it);
				                  item_remove(it);
				              }
				          }

				          return;
				      }
				      ITEM_set_cas(it, req_cas_id);

				      c->item = it;
				      c->ritem = ITEM_data(it);
				      c->rlbytes = it->nbytes;
				      c->cmd = comm;
				      conn_set_state(c, conn_nread);
				  }
	          	
	          </pre>
	        </div>
	      </div>
	    </div>
	    <div class="panel panel-default">
	      <div class="panel-heading">
	        <h4 class="panel-title">
	          <a data-toggle="collapse" data-parent="#accordion" href="#process_touch_command">
	            static void process_touch_command(conn *c, token_t *tokens, const size_t ntokens)
	          </a>
	        </h4>
	      </div>
	      <div id="process_touch_command" class="panel-collapse collapse">
	        <div class="panel-body">
	          <pre>
				  static void process_touch_command(conn *c, token_t *tokens, const size_t ntokens) {
				      char *key;
				      size_t nkey;
				      int32_t exptime_int = 0;
				      item *it;

				      assert(c != NULL);

				      set_noreply_maybe(c, tokens, ntokens);

				      if (tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {
				          out_string(c, "CLIENT_ERROR bad command line format");
				          return;
				      }

				      key = tokens[KEY_TOKEN].value;
				      nkey = tokens[KEY_TOKEN].length;

				      if (!safe_strtol(tokens[2].value, &exptime_int)) {
				          out_string(c, "CLIENT_ERROR invalid exptime argument");
				          return;
				      }

				      it = item_touch(key, nkey, realtime(exptime_int));
				      if (it) {
				          item_update(it);
				          pthread_mutex_lock(&c->thread->stats.mutex);
				          c->thread->stats.touch_cmds++;
				          c->thread->stats.slab_stats[it->slabs_clsid].touch_hits++;
				          pthread_mutex_unlock(&c->thread->stats.mutex);

				          out_string(c, "TOUCHED");
				          item_remove(it);
				      } else {
				          pthread_mutex_lock(&c->thread->stats.mutex);
				          c->thread->stats.touch_cmds++;
				          c->thread->stats.touch_misses++;
				          pthread_mutex_unlock(&c->thread->stats.mutex);

				          out_string(c, "NOT_FOUND");
				      }
				  }
	          	
	          </pre>
	        </div>
	      </div>
	    </div>
	    <div class="panel panel-default">
	      <div class="panel-heading">
	        <h4 class="panel-title">
	          <a data-toggle="collapse" data-parent="#accordion" href="#process_arithmetic_command">
	            static void process_arithmetic_command(conn *c, token_t *tokens, const size_t ntokens, const bool incr)
	          </a>
	        </h4>
	      </div>
	      <div id="process_arithmetic_command" class="panel-collapse collapse">
	        <div class="panel-body">
	          <pre>
				  static void process_arithmetic_command(conn *c, token_t *tokens, const size_t ntokens, const bool incr) {
				      char temp[INCR_MAX_STORAGE_LEN];
				      uint64_t delta;
				      char *key;
				      size_t nkey;

				      assert(c != NULL);

				      set_noreply_maybe(c, tokens, ntokens);

				      if (tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {
				          out_string(c, "CLIENT_ERROR bad command line format");
				          return;
				      }

				      key = tokens[KEY_TOKEN].value;
				      nkey = tokens[KEY_TOKEN].length;

				      if (!safe_strtoull(tokens[2].value, &delta)) {
				          out_string(c, "CLIENT_ERROR invalid numeric delta argument");
				          return;
				      }

				      switch(add_delta(c, key, nkey, incr, delta, temp, NULL)) {
				      case OK:
				          out_string(c, temp);
				          break;
				      case NON_NUMERIC:
				          out_string(c, "CLIENT_ERROR cannot increment or decrement non-numeric value");
				          break;
				      case EOM:
				          out_string(c, "SERVER_ERROR out of memory");
				          break;
				      case DELTA_ITEM_NOT_FOUND:
				          pthread_mutex_lock(&c->thread->stats.mutex);
				          if (incr) {
				              c->thread->stats.incr_misses++;
				          } else {
				              c->thread->stats.decr_misses++;
				          }
				          pthread_mutex_unlock(&c->thread->stats.mutex);

				          out_string(c, "NOT_FOUND");
				          break;
				      case DELTA_ITEM_CAS_MISMATCH:
				          break; /* Should never get here */
				      }
				  }
	          	
	          </pre>
	        </div>
	      </div>
	    </div>
	    <div class="panel panel-default">
	      <div class="panel-heading">
	        <h4 class="panel-title">
	          <a data-toggle="collapse" data-parent="#accordion" href="#do_add_delta">
				  enum delta_result_type do_add_delta(conn *c, const char *key, const size_t nkey,
				                                      const bool incr, const int64_t delta,
				                                      char *buf, uint64_t *cas,
				                                      const uint32_t hv)
	          </a>
	        </h4>
	      </div>
	      <div id="do_add_delta" class="panel-collapse collapse">
	        <div class="panel-body">
	          <pre>
				  /*
				   * adds a delta value to a numeric item.
				   *
				   * c     connection requesting the operation
				   * it    item to adjust
				   * incr  true to increment value, false to decrement
				   * delta amount to adjust value by
				   * buf   buffer for response string
				   *
				   * returns a response string to send back to the client.
				   */
				  enum delta_result_type do_add_delta(conn *c, const char *key, const size_t nkey,
				                                      const bool incr, const int64_t delta,
				                                      char *buf, uint64_t *cas,
				                                      const uint32_t hv) {
				      char *ptr;
				      uint64_t value;
				      int res;
				      item *it;

				      it = do_item_get(key, nkey, hv);
				      if (!it) {
				          return DELTA_ITEM_NOT_FOUND;
				      }

				      if (cas != NULL && *cas != 0 && ITEM_get_cas(it) != *cas) {
				          do_item_remove(it);
				          return DELTA_ITEM_CAS_MISMATCH;
				      }

				      ptr = ITEM_data(it);

				      if (!safe_strtoull(ptr, &value)) {
				          do_item_remove(it);
				          return NON_NUMERIC;
				      }

				      if (incr) {
				          value += delta;
				          MEMCACHED_COMMAND_INCR(c->sfd, ITEM_key(it), it->nkey, value);
				      } else {
				          if(delta > value) {
				              value = 0;
				          } else {
				              value -= delta;
				          }
				          MEMCACHED_COMMAND_DECR(c->sfd, ITEM_key(it), it->nkey, value);
				      }

				      pthread_mutex_lock(&c->thread->stats.mutex);
				      if (incr) {
				          c->thread->stats.slab_stats[it->slabs_clsid].incr_hits++;
				      } else {
				          c->thread->stats.slab_stats[it->slabs_clsid].decr_hits++;
				      }
				      pthread_mutex_unlock(&c->thread->stats.mutex);

				      snprintf(buf, INCR_MAX_STORAGE_LEN, "%llu", (unsigned long long)value);
				      res = strlen(buf);
				      if (res + 2 > it->nbytes || it->refcount != 1) { /* need to realloc */
				          item *new_it;
				          new_it = do_item_alloc(ITEM_key(it), it->nkey, atoi(ITEM_suffix(it) + 1), it->exptime, res + 2, hv);
				          if (new_it == 0) {
				              do_item_remove(it);
				              return EOM;
				          }
				          memcpy(ITEM_data(new_it), buf, res);
				          memcpy(ITEM_data(new_it) + res, "\r\n", 2);
				          item_replace(it, new_it, hv);
				          // Overwrite the older item's CAS with our new CAS since we're
				          // returning the CAS of the old item below.
				          ITEM_set_cas(it, (settings.use_cas) ? ITEM_get_cas(new_it) : 0);
				          do_item_remove(new_it);       /* release our reference */
				      } else { /* replace in-place */
				          /* When changing the value without replacing the item, we
				             need to update the CAS on the existing item. */
				          mutex_lock(&cache_lock); /* FIXME */
				          ITEM_set_cas(it, (settings.use_cas) ? get_cas_id() : 0);
				          mutex_unlock(&cache_lock);

				          memcpy(ITEM_data(it), buf, res);
				          memset(ITEM_data(it) + res, ' ', it->nbytes - res - 2);
				          do_item_update(it);
				      }

				      if (cas) {
				          *cas = ITEM_get_cas(it);    /* swap the incoming CAS value */
				      }
				      do_item_remove(it);         /* release our reference */
				      return OK;
				  }
	          	
	          </pre>
	        </div>
	      </div>
	    </div>
	    <div class="panel panel-default">
	      <div class="panel-heading">
	        <h4 class="panel-title">
	          <a data-toggle="collapse" data-parent="#accordion" href="#process_delete_command">
	            static void process_delete_command(conn *c, token_t *tokens, const size_t ntokens)
	          </a>
	        </h4>
	      </div>
	      <div id="process_delete_command" class="panel-collapse collapse">
	        <div class="panel-body">
	          <pre>
				  static void process_delete_command(conn *c, token_t *tokens, const size_t ntokens) {
				      char *key;
				      size_t nkey;
				      item *it;

				      assert(c != NULL);

				      if (ntokens > 3) {
				          bool hold_is_zero = strcmp(tokens[KEY_TOKEN+1].value, "0") == 0;
				          bool sets_noreply = set_noreply_maybe(c, tokens, ntokens);
				          bool valid = (ntokens == 4 && (hold_is_zero || sets_noreply))
				              || (ntokens == 5 && hold_is_zero && sets_noreply);
				          if (!valid) {
				              out_string(c, "CLIENT_ERROR bad command line format.  "
				                         "Usage: delete <key> [noreply]");
				              return;
				          }
				      }


				      key = tokens[KEY_TOKEN].value;
				      nkey = tokens[KEY_TOKEN].length;

				      if(nkey > KEY_MAX_LENGTH) {
				          out_string(c, "CLIENT_ERROR bad command line format");
				          return;
				      }

				      if (settings.detail_enabled) {
				          stats_prefix_record_delete(key, nkey);
				      }

				      it = item_get(key, nkey);
				      if (it) {
				          MEMCACHED_COMMAND_DELETE(c->sfd, ITEM_key(it), it->nkey);

				          pthread_mutex_lock(&c->thread->stats.mutex);
				          c->thread->stats.slab_stats[it->slabs_clsid].delete_hits++;
				          pthread_mutex_unlock(&c->thread->stats.mutex);

				          item_unlink(it);
				          item_remove(it);      /* release our reference */
				          out_string(c, "DELETED");
				      } else {
				          pthread_mutex_lock(&c->thread->stats.mutex);
				          c->thread->stats.delete_misses++;
				          pthread_mutex_unlock(&c->thread->stats.mutex);

				          out_string(c, "NOT_FOUND");
				      }
				  }
	          	
	          </pre>
	        </div>
	      </div>
	    </div>
	    <div class="panel panel-default">
	      <div class="panel-heading">
	        <h4 class="panel-title">
	          <a data-toggle="collapse" data-parent="#accordion" href="#process_verbosity_command">
	            static void process_verbosity_command(conn *c, token_t *tokens, const size_t ntokens)
	          </a>
	        </h4>
	      </div>
	      <div id="process_verbosity_command" class="panel-collapse collapse">
	        <div class="panel-body">
	          <pre>
				  static void process_verbosity_command(conn *c, token_t *tokens, const size_t ntokens) {
				      unsigned int level;

				      assert(c != NULL);

				      set_noreply_maybe(c, tokens, ntokens);

				      level = strtoul(tokens[1].value, NULL, 10);
				      settings.verbose = level > MAX_VERBOSITY_LEVEL ? MAX_VERBOSITY_LEVEL : level;
				      out_string(c, "OK");
				      return;
				  }
	          </pre>
	        </div>
	      </div>
	    </div>
	    <div class="panel panel-default">
	      <div class="panel-heading">
	        <h4 class="panel-title">
	          <a data-toggle="collapse" data-parent="#accordion" href="#process_slabs_automove_command">
	            static void process_slabs_automove_command(conn *c, token_t *tokens, const size_t ntokens)
	          </a>
	        </h4>
	      </div>
	      <div id="process_slabs_automove_command" class="panel-collapse collapse">
	        <div class="panel-body">
	          <pre>
				  static void process_slabs_automove_command(conn *c, token_t *tokens, const size_t ntokens) {
				      unsigned int level;

				      assert(c != NULL);

				      set_noreply_maybe(c, tokens, ntokens);

				      level = strtoul(tokens[2].value, NULL, 10);
				      if (level == 0) {
				          settings.slab_automove = 0;
				      } else if (level == 1 || level == 2) {
				          settings.slab_automove = level;
				      } else {
				          out_string(c, "ERROR");
				          return;
				      }
				      out_string(c, "OK");
				      return;
				  }
	          </pre>
	        </div>
	      </div>
	    </div>
  	  </div>
    </div>
  </body>
</html>




