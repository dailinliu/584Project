/**                                                                                                                                                                                
 * Copyright (c) 2012 USC Database Laboratory All rights reserved. 
 *
 * Authors:  Sumita Barahmand and Shahram Ghandeharizadeh                                                                                                                            
 *                                                                                                                                                                                 
 * Licensed under the Apache License, Version 2.0 (the "License"); you                                                                                                             
 * may not use this file except in compliance with the License. You                                                                                                                
 * may obtain a copy of the License at                                                                                                                                             
 *                                                                                                                                                                                 
 * http://www.apache.org/licenses/LICENSE-2.0                                                                                                                                      
 *                                                                                                                                                                                 
 * Unless required by applicable law or agreed to in writing, software                                                                                                             
 * distributed under the License is distributed on an "AS IS" BASIS,                                                                                                               
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or                                                                                                                 
 * implied. See the License for the specific language governing                                                                                                                    
 * permissions and limitations under the License. See accompanying                                                                                                                 
 * LICENSE file.                                                                                                                                                                   
 */


package common;


import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.util.HashMap;
import java.util.Vector;
import java.util.zip.DataFormatException;
import java.util.zip.Deflater;
import java.util.zip.Inflater;


import edu.usc.bg.base.ByteIterator;
import edu.usc.bg.base.ObjectByteIterator;

public class CacheUtilities {
	private static final int deserialize_buffer_size = 1024*1024;
	
	
	public static byte[] compressBytes(byte[] input) throws UnsupportedEncodingException, IOException
    {
        //byte[] input = data.getBytes("UTF-8");  //the format... data is the total string
        Deflater df = new Deflater();       //this function mainly generate the byte code
        df.setLevel(Deflater.BEST_COMPRESSION);
        df.setInput(input);
 
        ByteArrayOutputStream baos = new ByteArrayOutputStream(input.length);   //we write the generated byte code in this array
        df.finish();
        byte[] buff = new byte[1024];   //segment segment pop....segment set 1024
        while(!df.finished())
        {
            int count = df.deflate(buff);       //returns the generated code... index
            baos.write(buff, 0, count);     //write 4m 0 to count
        }
        baos.close();
        byte[] output = baos.toByteArray();
        
        return output;
    }
 
	public static byte[] decompressBytes(byte[] input) throws UnsupportedEncodingException, IOException, DataFormatException
    {
        Inflater ifl = new Inflater();   //mainly generate the extraction
        ifl.setInput(input);
 
        ByteArrayOutputStream baos = new ByteArrayOutputStream(input.length);
        byte[] buff = new byte[1024];
        while(!ifl.finished())
        {
            int count = ifl.inflate(buff);
            baos.write(buff, 0, count);
        }
        baos.close();
        byte[] output = baos.toByteArray();
        
        return output;
    }

	public static byte[] SerializeHashMap(HashMap<String, ByteIterator> m){
		ByteArrayOutputStream bos = new ByteArrayOutputStream();
		DataOutputStream out = new DataOutputStream(bos);
		try {
			out.writeInt(m.size());


			for (String s: m.keySet()){
				out.writeInt(s.length());
				out.writeBytes(s);
				ByteIterator vBI = m.get(s);

				//String v = vBI.toString();
				byte[] v = vBI.toArray();
				out.writeInt(v.length);
				out.write(v);
				
				/* Offset has to be reset because toArray consumes the data.
				 * Needed because the StringByteIterator toString works does not
				 *  follow the description in ByteIterator (returns a reference
				 *  to the original string
				 *  without consuming the data if called before anyone
				 *  has started consuming data). Because of this, outside code
				 *  has been using toString to repeatedly obtain data when
				 *  they shouldn't be using ByteIterator like that.
				 */				
				if( vBI instanceof ObjectByteIterator )
				{
					((ObjectByteIterator)vBI).resetOffset();
				}
				
			}
		} catch (Exception e) {
			System.out.println("Error, ApplicationCacheClient failed to serialize HashMap.  This is a catastrophic error");
			e.printStackTrace(System.out);
		} 
		finally {
			try {
				out.flush();
				out.close();
			} catch (Exception e) {
				System.out.println("Error, ApplicationCacheClient failed to flush output buffers.");
				e.printStackTrace(System.out);
			}
		}		
		return bos.toByteArray();
	}

	public static byte[] SerializeVectorOfHashMaps(Vector<HashMap<String, ByteIterator>> m){
		ByteArrayOutputStream bos = new ByteArrayOutputStream();
		DataOutputStream out = new DataOutputStream(bos);
		try {
			out.writeInt(m.size());
			for (int i=0; i < m.size(); i++){
				byte[] oneHM = SerializeHashMap(m.elementAt(i));
				out.write(oneHM, 0, oneHM.length);
			}
		} catch (Exception e) {
			System.out.println("Error, ApplicationCacheClient failed to serialize HashMap.  This is a catastrophic error");
			e.printStackTrace(System.out);
		} 
		finally {
			try {
				out.flush();
				out.close();
			} catch (Exception e) {
				System.out.println("Error, ApplicationCacheClient failed to flush output buffers.");
				e.printStackTrace(System.out);
			}
		}		
		return bos.toByteArray();
	}
	
	public static byte[] SerializeVectorOfInts(Vector<Integer> m){
		ByteArrayOutputStream bos = new ByteArrayOutputStream();
		DataOutputStream out = new DataOutputStream(bos);
		try {
			out.writeInt(m.size());
			for (int i=0; i < m.size(); i++){
				out.writeInt(m.get(i));
			}
		} catch (Exception e) {
			System.out.println("Error in SerializeVectorOfInts, ApplicationCacheClient failed to serialize Vector of Integer.  This is a catastrophic error");
			e.printStackTrace(System.out);
		} 
		finally {
			try {
				out.flush();
				out.close();
			} catch (Exception e) {
				System.out.println("Error in SerializeVectorOfInts, ApplicationCacheClient failed to flush output buffers.");
				e.printStackTrace(System.out);
			}
		}		
		return bos.toByteArray();
	}

	private static void readObject( DataInputStream in, int num_bytes, byte[] byte_array ) throws IOException
	{
		int total_bytes_read = 0;
		int bytes_read = 0;

		while( total_bytes_read < num_bytes )
		{
			bytes_read = in.read(byte_array, total_bytes_read, num_bytes - total_bytes_read);
			total_bytes_read += bytes_read;
		}		
	}

	public static boolean unMarshallHashMap(HashMap<String, ByteIterator> m, byte[] payload){
		boolean result = true;
		try {
			// Read from byte_array
			ByteArrayInputStream bis = new ByteArrayInputStream(payload);
			DataInputStream in = new DataInputStream(bis);
			int numkeys = in.readInt();

			byte[] buffer = new byte[deserialize_buffer_size];
			int field_size = 0;		
			String key = null;
			byte[] val = null;
			//String val;
			for( int k = 0; k < numkeys; k++ )
			{
				field_size = in.readInt();
				readObject(in, field_size, buffer);
				key = new String(buffer, 0, field_size);

				field_size = in.readInt();
				readObject(in, field_size, buffer);
				//val = new String(buffer, 0, field_size);
				val = new byte[field_size];
				System.arraycopy( buffer, 0, val, 0, field_size );

				//m.put(key, new StringByteIterator(val, 0, field_size)) ;
				m.put(key, new ObjectByteIterator(val));
			}
		} catch (Exception e) {
			e.printStackTrace(System.out);
			System.out.println("Error, ApplicationCacheClient failed to unMarshall bytearray into a HashMap.");
		}
		return result;
	}

	public static boolean unMarshallVectorOfHashMaps(byte[] payload, Vector<HashMap<String, ByteIterator>> V){
		boolean result = true;
		byte[] buffer = new byte[deserialize_buffer_size];
		//Vector<HashMap<String, ByteIterator>> V = new Vector<HashMap<String, ByteIterator>> ();
		try {
			// Read from byte_array
			ByteArrayInputStream bis = new ByteArrayInputStream(payload);
			DataInputStream in = new DataInputStream(bis);
			int numelts = in.readInt();
			for (int i=0; i < numelts; i++){
				//buffer = new byte[deserialize_buffer_size];
				int field_size = 0;		
				String key = null;
				byte[] val = null;
				//String val;
				int numkeys = in.readInt();
				HashMap<String, ByteIterator> m = new HashMap<String, ByteIterator>();
				for( int k = 0; k < numkeys; k++ )
				{
					field_size = in.readInt();
					readObject(in, field_size, buffer);
					key = new String(buffer, 0, field_size);

					field_size = in.readInt();
					readObject(in, field_size, buffer);
					//val = new String(buffer, 0, field_size);
					val = new byte[field_size];
					System.arraycopy( buffer, 0, val, 0, field_size );

					//m.put(key, new ObjectByteIterator(val.getBytes())) ;
					m.put(key, new ObjectByteIterator(val)) ;
				}
				V.addElement(m);
			}
		} catch (Exception e) {
			e.printStackTrace(System.out);
			System.out.println("Error, ApplicationCacheClient failed to unMarshall bytearray into a HashMap.");
			result = false;
		}	
		return result;
	}
	
	public static boolean unMarshallVectorOfInts(byte[] payload, Vector<Integer> V){
		boolean result = true;
		int value;
		try {
			// Read from byte_array
			ByteArrayInputStream bis = new ByteArrayInputStream(payload);
			DataInputStream in = new DataInputStream(bis);
			int numelts = in.readInt();
			for (int i=0; i < numelts; i++){
				value = in.readInt();
				V.addElement(value);
			}
		} catch (Exception e) {
			e.printStackTrace(System.out);
			System.out.println("Error, ApplicationCacheClient failed to unMarshall bytearray into a Vector of Integer.");
			result = false;
		}	
		return result;
	}
}
